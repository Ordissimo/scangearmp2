Description: Add sane backend.
 TODO: This project is a sane backend for the canon's scanner,
 based on the source code of scangearmp2..
 .
 scangearmp2 (3.40-1) stable; urgency=low
 .
   * Initial Release.
Author: Canon Inc. <sup-debian@list.canon.co.jp>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

Index: scangearmp2/scangearmp2/configure.in
===================================================================
--- scangearmp2.orig/scangearmp2/configure.in	2017-08-09 11:28:10.909567979 +0200
+++ scangearmp2/scangearmp2/configure.in	2017-08-09 11:28:34.000000000 +0200
@@ -1,6 +1,8 @@
 dnl Process this file with autoconf to produce a configure script.
 
-AC_INIT(configure.in)
+AC_PREREQ(2.61)
+AC_INIT([scangearmp2],[3.40-1])
+# AC_INIT(configure.in)
 
 AC_ARG_ENABLE(libpath)
 if test "${enable_libpath}" = ""; then
@@ -12,8 +14,10 @@
 
 AC_SUBST(enable_libpath)
 
-AM_INIT_AUTOMAKE(scangearmp2, 3.40-1)
+# AM_INIT_AUTOMAKE(scangearmp2, 3.40-1)
+AM_INIT_AUTOMAKE([subdir-objects])
 AM_CONFIG_HEADER(config.h)
+
 AM_PROG_LIBTOOL
 AC_PROG_LIBTOOL
 AM_MAINTAINER_MODE
Index: scangearmp2/scangearmp2/src/Makefile.am
===================================================================
--- scangearmp2.orig/scangearmp2/src/Makefile.am	2017-08-09 11:28:10.913567979 +0200
+++ scangearmp2/scangearmp2/src/Makefile.am	2017-08-09 11:28:34.000000000 +0200
@@ -1,4 +1,5 @@
 ## Process this file with automake to produce Makefile.in
+# SUBDIRS = sane
 
 INCLUDES = \
 	-I$(top_srcdir)/include \
@@ -34,6 +35,33 @@
 	-DPACKAGE_DATA_DIR=\""$(datadir)/$(PACKAGE)"\" \
 	-DPACKAGE_LOCALE_DIR=\""$(prefix)/$(DATADIRNAME)/locale"\"
 
+# UNAME = `shell uname -m`
+
+# libsane_canon_pixmadir = /usr/lib/x86_64-linux-gnu/sane
+libsane_canon_pixmadir = /usr/lib/x86_64-linux-gnu/sane
+libsane_canon_pixma_LTLIBRARIES = libsane-canon_pixma.la
+libsane_canon_pixma_la_SOURCES = sane/saneopts.h sane/sane.h sane/sanei_debug.h \
+	sane/sanei.h sane/sanei_init_debug.c sane/sanei_backend.h \
+	sane/canon_pixma.c sane/canon_pixma.h sane/errordlg.c sane/errordlg.h \
+	keep_setting.c canon_mfp_io.c cnmsstrings.h errors.h \
+	keep_setting.h canon_mfp_tools.c file_control.c canon_mfp_tools.h \
+	cnmsfunc.c cnmsfunc.h file_control.h support.h
+libsane_canon_pixma_la_LDFLAGS = -version-info 1:0:0
+# The following is a interlibrary dependency that must be compiled first.
+# if [ "$(UNAME)" = "x86_64" ]
+# then
+libsane_canon_pixma_la_LIBADD = -L$(top_srcdir)/../com/libs_bin64 -lcncpmslld2 -lcncpnet2 -lcncpnet20 -lcncpnet30 -lpthread -ldl $(LIBUSB_1_0_LIBS)
+# fi
+# if [ "$(UNAME)" <> "x86_64" ]
+# then
+# 	libsane_canon_pixma_la_LIBADD = -L$(top_srcdir)/../com/libs_bin32 -lcncpmslld2 -lcncpnet2 -lcncpnet20 -lcncpnet30 -lpthread -ldl $(LIBUSB_1_0_LIBS)
+# fi
+#libsane_canon_pixma_la_CFLAGS = -DWITH_NONAMESPACES -DSOAP_DEBUG
+libsane_canon_pixma_la_CFLAGS = $(LIBUSB_1_0_CFLAGS) -I$(top_srcdir)/include
+
+
+
+
 install-data-am:
 	if test ! -d $(DESTDIR)$(enable_libpath)/bjlib; then mkdir -p $(DESTDIR)$(enable_libpath)/bjlib ; fi ; \
 	$(INSTALL_DATA) canon_mfp2.conf $(DESTDIR)$(enable_libpath)/bjlib
Index: scangearmp2/scangearmp2/src/canon_mfp_io.c
===================================================================
--- scangearmp2.orig/scangearmp2/src/canon_mfp_io.c	2017-08-09 11:28:10.913567979 +0200
+++ scangearmp2/scangearmp2/src/canon_mfp_io.c	2017-08-09 11:33:05.225555851 +0200
@@ -73,11 +73,11 @@
 
     size_t		bytes_to_read;
     int			scanning;
-    
+
     /* add Ver.1.30 */
     int			scanMethod;
     int			CIJSC_start_status;
-    
+
     int		scanFinished;
   }
 CANON_Scanner;
@@ -109,7 +109,7 @@
 			return status;
 		}
 		CANON_fd = fd;
-		
+
 		return CMT_STATUS_GOOD;
 	}
 	else { /* already open. */
@@ -132,16 +132,16 @@
 {
 	unsigned long n = size;
 	CMT_Status status;
-	
+
 	if ( CANON_fd < 0 ) {
 		return -1; /* error */
 	}
 	status = cmt_libusb_bulk_write ( CANON_fd, buffer, &n );
-	
+
 	if ( status != CMT_STATUS_GOOD ) {
 		return -1; /* error */
 	}
-	
+
 	if ( size != n ) {
 		return n; /* error */
 	}
@@ -152,18 +152,18 @@
 {
 	unsigned long n = *size;
 	CMT_Status status;
-	
+
 	if ( CANON_fd < 0 ) {
 		return -1; /* error */
 	}
 	status = cmt_libusb_bulk_read ( CANON_fd, buffer, &n );
-		
+
 	if ( status != CMT_STATUS_GOOD ) {
 		return -1; /* error */
 	}
-	
+
 	*size = n;
-	
+
 	if ( *size != n ) {
 		return n; /* error */
 	}
@@ -177,7 +177,7 @@
 {
 	CMT_Status status;
 	CNNLHANDLE handle = NULL;
-	
+
 	if ( CANON_hnd == NULL ) {
 		if ( ( status = cmt_network_open ((const char *)devname, &handle) ) != CMT_STATUS_GOOD ) {
 			return status;
@@ -206,16 +206,16 @@
 {
 	unsigned long n = size;
 	CMT_Status status;
-	
+
 	if ( CANON_hnd == NULL ) {
 		return -1; /* error */
 	}
 	status = cmt_network_write ( CANON_hnd, buffer, &n );
-	
+
 	if ( status != CMT_STATUS_GOOD ) {
 		return -1; /* error */
 	}
-	
+
 	if ( size != n ) {
 		return n; /* error */
 	}
@@ -226,18 +226,18 @@
 {
 	unsigned long n = *size;
 	CMT_Status status;
-	
+
 	if ( CANON_hnd == NULL ) {
 		return -1; /* error */
 	}
 	status = cmt_network_read ( CANON_hnd, buffer, &n );
-		
+
 	if ( status != CMT_STATUS_GOOD ) {
 		return -1; /* error */
 	}
-	
+
 	*size = n;
-	
+
 	if ( *size != n ) {
 		return n; /* error */
 	}
@@ -251,7 +251,7 @@
 {
 	CMT_Status status;
 	HCNNET3 handle = NULL;
-	
+
 	if ( CANON_hnd2 == NULL ) {
 		if ( ( status = cmt_network2_open ((const char *)devname, &handle) ) != CMT_STATUS_GOOD ) {
 			return status;
@@ -280,16 +280,16 @@
 {
 	unsigned long n = size;
 	CMT_Status status;
-	
+
 	if ( CANON_hnd2 == NULL ) {
 		return -1; /* error */
 	}
 	status = cmt_network2_write ( CANON_hnd2, buffer, &n );
-	
+
 	if ( status != CMT_STATUS_GOOD ) {
 		return -1; /* error */
 	}
-	
+
 	if ( size != n ) {
 		return n; /* error */
 	}
@@ -300,18 +300,18 @@
 {
 	unsigned long n = *size;
 	CMT_Status status;
-	
+
 	if ( CANON_hnd2 == NULL ) {
 		return -1; /* error */
 	}
 	status = cmt_network2_read ( CANON_hnd2, buffer, &n );
-		
+
 	if ( status != CMT_STATUS_GOOD ) {
 		return -1; /* error */
 	}
-	
+
 	*size = n;
-	
+
 	if ( *size != n ) {
 		return n; /* error */
 	}
@@ -356,27 +356,27 @@
 	int				vendor;
 	int				product;
 	int				speed = 2;
-	
+
 	int				usb_opend = 0;
 	int				flag_usb = 0, i = 0;
 
 	if( strncmp( name, "libusb:", 7 ) >= 0 ){
 		flag_usb = 1;
 	}
-	
+
 	for (dev = *first; dev; dev = dev->next) {
 		if ( strcmp(dev->name, name) == 0 ) {
 			return (CMT_STATUS_GOOD);		/* already exists. */
 		}
 	}
-	
+
 	dev = malloc( sizeof( CANON_Device ) );
 	if ( !dev ) {
 		status = CMT_STATUS_NO_MEM;
 		goto _ERROR;
 	}
 	memset( dev, 0, sizeof(*dev) );
-	
+
 	if(flag_usb){
 		/* open succeed -> append to list */
 		if ( ( status = canon_usb_open(name) ) != CMT_STATUS_GOOD )
@@ -396,7 +396,7 @@
 		speed = attach_dev->speed;
 		product = attach_dev->product_id;
 	}
-	
+
 	/* set name */
 	dev->name = strdup( name );
 	/* set model */
@@ -404,12 +404,12 @@
 	/* set full name */
 	snprintf( dev_fullname, sizeof(dev_fullname), "Canon %s (%s)", dev->model, dev->name );
 	dev->fullname = strdup( dev_fullname );
-	
+
 	if(flag_usb){
 		canon_usb_close();
 		usb_opend = 0;
 	}
-	
+
 	dev->product_id = product;
 	dev->type = attach_dev->type;
 	dev->speed = speed;
@@ -429,12 +429,12 @@
 			}
 		}
 	}
-	
+
 	return status;
 
 _ERROR:
 	dispose_canon_dev( dev );
-	
+
 	if(flag_usb){
 		if ( usb_opend ) {
 			canon_usb_close();
@@ -450,38 +450,38 @@
 CMT_Status CIJSC_init( void *cnnl_callback )
 {
 	CMT_Status status = CMT_STATUS_GOOD;
-	
+
 	FILE *fp = NULL;
 	CANON_Device	*first_usb = NULL, *first_net = NULL, *first_net2 = NULL, *tmp_dev;
 	CANON_Device	c_dev;
 	int		i;
-	
+
 	num_devices = 0;
-	
+
 	/* initialize libUSB */
 	cmt_libusb_init();
-	
+
 	/* initialize Network */
 	cmt_network_init( cnnl_callback );
-	
+
 	/* initialize Network2 */
 	cmt_network2_init( cnnl_callback );
-	
+
 	/*--- read Configuration file. ---*/
 	fp = cmt_conf_file_open( CANON_CONFIG_FILE );
-	
+
 	if ( fp ) {
 		char line[PATH_MAX];
 		int len, ret;
 		char *dev;
 		int index_usb, index_net, index_net2;
-		
+
 		/* Set USB/Network device list */
 		while ( ( len = cmt_conf_file_read_line( line, sizeof(line), fp ) ) >= 0 ) {
 			index_usb = 0;
 			index_net = 0;
 			index_net2 = 0;
-			
+
 			if ( ( ret = cmt_get_device_info( line, len, &c_dev ) ) < 0 ) {
 				continue;	/* next */
 			}
@@ -561,12 +561,12 @@
 		dispose_canon_dev( dev );
 	}
 	first_dev = NULL;
-	
+
 	if( devlist ){
 		free( devlist );
 	}
 	devlist = NULL;
-	
+
 	num_devices = 0;
 	cmt_libusb_exit();
 	cmt_network_exit();
@@ -586,7 +586,7 @@
 	if( devlist ){
 		free( devlist );
 	}
-	
+
 	devlist = malloc( ( num_devices + 1 ) * sizeof( CANON_Device * ) );
 	if( !devlist ) {
 		return (CMT_STATUS_NO_MEM);
@@ -594,7 +594,7 @@
 	for( dev = first_dev, devlisttemp = devlist; dev; dev = dev->next ) {
 		*devlisttemp++ = dev;
 	}
-	
+
 	*devlisttemp = NULL;
 	*device_list = devlist;
 
@@ -609,25 +609,25 @@
 {
 	CMT_Status status;
 	CANON_Device *dev;
-	int i;
+//	int i;
 	CANON_Scanner *s = &canon_device;
-	
+
 	if ( opened_handle ) {
 		DBGMSG("ERROR : Another CANON MFP Deviece has opened already.\n");
 		return (CMT_STATUS_INVAL);
 	}
-	
+
 	if ( !name ) {
 		return (CMT_STATUS_INVAL);
 	}
-	
+
 	if ( name[0] != '\0' ) {
 		for (dev = first_dev; dev; dev = dev->next) {
 			if (strcmp (dev->name, name) == 0) {
 				break;
 			}
 		}
-		
+
 		if (!dev) {
 			return (CMT_STATUS_INVAL);
 		}
@@ -635,7 +635,7 @@
 	else {
 		dev = first_dev;
 	}
-	
+
 	DBGMSG(" dev->speed = %d \n" ,dev->speed);
 	if ( dev->speed == -1 ){	/* NET */
 		if( ( status = canon_network_open ( name ) ) != CMT_STATUS_GOOD ){
@@ -676,20 +676,108 @@
 			}
 		}
 	}
-	
+
 	/* set product id. */
 	DBGMSG("p_canon_init_scanner() product = %X\n", dev->product_id);
 	if ( canon_init_scanner( dev->product_id, dev->speed, NULL ) < 0 ) {
 		DBGMSG("ERROR : p_canon_init_scanner() product = %d\n", dev->product_id);
 		return (CMT_STATUS_INVAL);
 	}
-	
+
 	opened_handle = dev;
 	memset(&canon_device, 0, sizeof(canon_device));
-	
+
 	s->scanMethod = 0;
 	s->CIJSC_start_status = CMT_STATUS_NO_DOCS;
-	
+
+	return CMT_STATUS_GOOD;
+}
+
+CMT_Status CIJSC_open2(
+	const char *name,CANON_Device *dev )	/* libusb:00X:00Y or MAC address */
+{
+	CMT_Status status;
+//	int i;
+	CANON_Scanner *s = &canon_device;
+
+	if ( opened_handle ) {
+		DBGMSG("ERROR : Another CANON MFP Deviece has opened already.\n");
+		return (CMT_STATUS_INVAL);
+	}
+
+	if ( !name ) {
+		return (CMT_STATUS_INVAL);
+	}
+
+	if ( name[0] != '\0' ) {
+		for (dev = first_dev; dev; dev = dev->next) {
+			if (strcmp (dev->name, name) == 0) {
+				break;
+			}
+		}
+
+		if (!dev) {
+			return (CMT_STATUS_INVAL);
+		}
+	}
+	else {
+		dev = first_dev;
+	}
+
+	DBGMSG(" dev->speed = %d \n" ,dev->speed);
+	if ( dev->speed == -1 ){	/* NET */
+		if( ( status = canon_network_open ( name ) ) != CMT_STATUS_GOOD ){
+			DBGMSG("ERROR : canon_network_open() \n");
+			return status;
+		}
+		else {
+			/* set func-pointer (read, write) */
+			if ( canon_init_driver( canon_network_read, canon_network_write ) < 0 ) {
+				DBGMSG("ERROR : p_canon_init_driver() \n");
+				return (CMT_STATUS_INVAL);
+			}
+		}
+	}
+	else if ( dev->speed == -2 ){	/* NET2 */
+		if( ( status = canon_network2_open ( dev->ipaddress ) ) != CMT_STATUS_GOOD ){
+			DBGMSG("ERROR : canon_network2_open() \n");
+			return status;
+		}
+		else {
+			/* set func-pointer (read, write) */
+			if ( canon_init_driver( canon_network2_read, canon_network2_write ) < 0 ) {
+				DBGMSG("ERROR : p_canon_init_driver() \n");
+				return (CMT_STATUS_INVAL);
+			}
+		}
+	}
+	else {	/* USB */
+		if ( ( status = canon_usb_open ( name ) ) != CMT_STATUS_GOOD ) {
+			DBGMSG("ERROR : canon_usb_open() \n");
+			return status;
+		}
+		else {
+			/* set func-pointer (read, write) */
+			if ( canon_init_driver( canon_usb_read, canon_usb_write ) < 0 ) {
+				DBGMSG("ERROR : p_canon_init_driver() \n");
+				return (CMT_STATUS_INVAL);
+			}
+		}
+	}
+
+	/* set product id. */
+	DBGMSG("p_canon_init_scanner() product = %X\n", dev->product_id);
+	if ( canon_init_scanner( dev->product_id, dev->speed, NULL ) < 0 ) {
+		DBGMSG("ERROR : p_canon_init_scanner() product = %d\n", dev->product_id);
+		return (CMT_STATUS_INVAL);
+	}
+
+	opened_handle = dev;
+	memset(&canon_device, 0, sizeof(canon_device));
+
+	s->scanMethod = 0;
+	s->CIJSC_start_status = CMT_STATUS_NO_DOCS;
+
 	return CMT_STATUS_GOOD;
 }
 
@@ -699,7 +787,7 @@
 void CIJSC_close( void )
 {
 	canon_terminate_scanner();
-	
+
 	canon_usb_close ();
 	canon_network_close();
 	canon_network2_close();
@@ -717,30 +805,30 @@
 	int status;
 	CANON_Scanner *s = &canon_device;
 	CANON_SCANDATA	scandata;
-	
+
 	DBGMSG("\n");
-	
+
 	if ( s->CIJSC_start_status == CMT_STATUS_NO_DOCS ) {
 		cmt_network_mutex_lock();
 	}
-	
+
 	s->scanning = TRUE;
 	s->scanFinished = FALSE;
-	
+
 	s->xres = param->XRes;
 	s->yres = param->YRes;
-	
+
 	/* use pixels */
 	s->ulx = ( param->Left * CANONMUD ) / s->xres;
 	s->uly = ( param->Top  * CANONMUD ) / s->yres;
-	
+
 	s->width  = ( ( param->Right  - param->Left ) * CANONMUD ) / s->xres;
 	s->length = ( ( param->Bottom - param->Top  ) * CANONMUD ) / s->yres;
-	
+
 	s->bpp = 8;
-	
+
 	s->scanMethod = param->ScanMethod;
-	
+
 	status = canon_set_parameter_ex(
 		s->xres,			/* XRes */
 		s->yres,			/* YRes */
@@ -755,7 +843,7 @@
 		&scandata,			/* CANON_SCANDATA */
 		&(param->opts)	/* CANON_SCANOPTS */
 	);
-	
+
 	if ( status < 0 ) {
 		DBGMSG("error in canon_set_parameter/canon_set_parameter_ex()\n");
 		status = CMT_STATUS_INVAL;
@@ -767,18 +855,18 @@
 		cmt_network_mutex_unlock();
 		goto _EXIT;
 	}
-	
+
 	if ( canon_start_scan() < 0 ) {
 		DBGMSG("error in canon_start_scan()\n");
 		status = CMT_STATUS_INVAL;
 		goto _EXIT;
 	}
-	
+
 	status = CMT_STATUS_GOOD;
 
 _EXIT:
 	s->CIJSC_start_status = status;
-	
+
 	return status;
 }
 
@@ -788,7 +876,7 @@
 CMT_Status CIJSC_get_parameters( void *callback )
 {
 	CANON_SCANDATA		scandata;
-	
+
 	if ( canon_get_parameters( &scandata, callback ) < 0 ) {
 		return CMT_STATUS_INVAL;
 	}
@@ -816,11 +904,11 @@
 	CMT_Status status;
 	int nread;
 	CANON_Scanner *s = &canon_device;
-	
+
 	if ( s->scanFinished ) {
 		s->scanning = FALSE;
 		status = canon_end_scan();
-		
+
 		status = CMT_STATUS_EOF;
 		goto _EXIT;
 	}
@@ -830,18 +918,18 @@
 		goto _EXIT;
 	}
 	nread = ( *len * 32 ) / 32;
-	
+
 	if ( ( *len = canon_read_scan ( buf, nread ) ) < 0 ) {
 		status = CMT_STATUS_IO_ERROR;
 		goto _EXIT;
 	}
-	
+
 	if ( *len == 0 ) {
 		s->scanFinished = TRUE;
 		status = CMT_STATUS_EOF;
 		goto _EXIT;
 	}
-	
+
 	status = CMT_STATUS_GOOD;
 
 _EXIT:
@@ -855,11 +943,11 @@
 {
 	CANON_Scanner *s = &canon_device;
 	int			skip_unlock = 0;
-	
+
 	DBGMSG("\n");
-	
+
 	s->scanning = FALSE;
-	
+
 	if ( s->scanFinished ) {
 		/* end scan */
 		if ( s->scanMethod ) {	/* ADF */
@@ -880,11 +968,11 @@
 		/* user cancel */
 		canon_do_cancel();
 	}
-	
+
 	if( !skip_unlock ) {
 		cmt_network_mutex_unlock();
 	}
-	
+
 	/* for next CIJSC_start */
 	s->CIJSC_start_status = CMT_STATUS_NO_DOCS;
 }
Index: scangearmp2/scangearmp2/src/canon_mfp_tools.h
===================================================================
--- scangearmp2.orig/scangearmp2/src/canon_mfp_tools.h	2017-08-09 11:28:10.917567978 +0200
+++ scangearmp2/scangearmp2/src/canon_mfp_tools.h	2017-08-09 11:28:34.000000000 +0200
@@ -156,6 +156,7 @@
 void CIJSC_exit(void);
 CMT_Status CIJSC_get_devices( const CANON_Device ***device_list );
 CMT_Status CIJSC_open( const char *name );
+CMT_Status CIJSC_open2( const char *name, CANON_Device *dev );
 void CIJSC_close( void );
 
 CMT_Status CIJSC_start( CANON_ScanParam *param );
Index: scangearmp2/scangearmp2/src/sane/canon_pixma.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ scangearmp2/scangearmp2/src/sane/canon_pixma.c	2017-08-09 11:38:22.345542783 +0200
@@ -0,0 +1,1005 @@
+/*******************************************************************
+ ** SANE API
+ *******************************************************************/
+
+#define _GNU_SOURCE
+#include "canon_pixma.h"
+//revoir les paths et ajouter les paths manquants
+#include "sane.h"
+#include "saneopts.h"
+#include "sanei.h"
+#include "sanei_backend.h"
+#include <jpeglib.h>
+#include <setjmp.h>
+#include <unistd.h>
+
+#ifdef __GNUC__
+# define UNUSED(v) (void) v
+#else
+# define UNUSED(v)
+#endif
+#define	JPEGSCANBUFSIZE	(0x4000)	/* 16k */
+#define min(A,B) (((A)<(B)) ? (A) : (B))
+#define max(A,B) (((A)>(B)) ? (A) : (B))
+CNMSInt32 lastIOErrCode = 0;
+CNMSInt32 lastBackendErrCode = 0;
+CNMSInt32 lastModuleErrCode = 0;
+
+static const char vendor_str[] = "CANON";
+static const char type_str[] = "multi-function peripheral";
+
+static const SANE_Device **dev_list = NULL;
+
+
+typedef struct Handled{
+	struct Handled * next;
+	SGMP_Data_Lite sgmp;
+	CANON_Device dev;
+	CANON_ScanParam param;
+	SANE_Option_Descriptor opt[NUM_OPTIONS];
+	Option_Value val[NUM_OPTIONS];
+	SANE_Range x_range;
+	SANE_Range y_range;
+
+	unsigned char * img_data;
+	long img_size;
+	long img_read;
+	SANE_Bool jpeg_header_seen;
+	SANE_Bool cancel;
+	SANE_Bool write_scan_data;
+	SANE_Bool decompress_scan_data;
+	SANE_Bool end_read;
+}  canon_sane_t;
+
+typedef struct {
+	int			id;
+	int			right;
+	int			bottom;
+} CIJSC_SIZE_TABLE;
+
+enum{
+	CIJSC_SCANMAIN_GO_NEXT = 0,
+	CIJSC_SCANMAIN_CHECK_ERROR_VALUE,
+	CIJSC_SCANMAIN_ERROR,
+};
+
+enum{
+	CIJSC_SCANMAIN_SCAN_FINISHED = 0,
+	CIJSC_SCANMAIN_SCAN_CANCELED,
+	CIJSC_SCANMAIN_SCAN_ERROR,
+};
+
+static const CIJSC_SIZE_TABLE sourceSize[] = {
+	{ CIJSC_SIZE_CARD,		1074,  649 },		// Card
+	{ CIJSC_SIZE_L_L,		1500, 1051 },		// L Landscape
+	{ CIJSC_SIZE_L_P,		1051, 1500 },		// L Portrait
+	{ CIJSC_SIZE_4X6_L,		1800, 1200 },		// 4"x6" Landscape
+	{ CIJSC_SIZE_4X6_P,		1200, 1800 },		// 4"x6" Portrait
+	{ CIJSC_SIZE_HAGAKI_L,	1748, 1181 },		// Hagaki Landscape
+	{ CIJSC_SIZE_HAGAKI_P,	1181, 1748 },		// Hagaki Portrait
+	{ CIJSC_SIZE_2L_L,		2102, 1500 },		// 2L Landscape
+	{ CIJSC_SIZE_2L_P,		1500, 2102 },		// 2L Portrait
+	{ CIJSC_SIZE_A5,		1748, 2480 },		// A5
+	{ CIJSC_SIZE_B5,		2149, 3035 },		// B5
+	{ CIJSC_SIZE_A4,		2480, 3507 },		// A4 size
+	{ CIJSC_SIZE_LETTER,	2550, 3300 }		// Letter
+};
+
+static const SANE_String_Const mode_list[] = {
+  SANE_VALUE_SCAN_MODE_GRAY, SANE_VALUE_SCAN_MODE_COLOR,
+  0
+};
+
+static const SANE_Int resbit_list[] =
+{
+	5,75, 100, 150, 200, 300
+};
+
+const char *canonJpegDataTmp = "/tmp/jpeg_canon.tmp";// "jpeg_canon.jpg";
+
+ SANE_Device*  convertFromCanonDev(const CANON_Device* cdev){
+	SANE_Device* sdev = NULL;
+	fprintf(stderr,"%s, %s ,%d ",__FILE__,__FUNCTION__,__LINE__);
+	sdev = calloc(1, sizeof(SANE_Device));
+	sdev->name = cdev->name;
+	sdev->model = cdev->model;
+	sdev->vendor = "CANON";
+	sdev->type = "flatbed scanner";
+	return sdev;
+}
+void show_canon_cmt_error(CMT_Status status) {
+	fprintf(stderr,"Error my backend :\t");
+	switch(status) {
+		case CMT_STATUS_UNSUPPORTED:
+			fprintf(stderr,"Operation is not supported");
+			break;
+		case CMT_STATUS_CANCELLED:
+			fprintf(stderr,"operation was cancelled");
+			break;
+		case CMT_STATUS_DEVICE_BUSY:
+			fprintf(stderr,"device is busy; try again later");
+			break;
+		case CMT_STATUS_INVAL:
+			fprintf(stderr,"data is invalid (includes no dev at open)");
+			break;
+		case CMT_STATUS_EOF:
+			fprintf(stderr,"no more data available (end-of-file)");
+			break;
+		case CMT_STATUS_JAMMED:
+			fprintf(stderr,"document feeder jammed");
+			break;
+		case CMT_STATUS_NO_DOCS:
+			fprintf(stderr,"document feeder out of documents");
+			break;
+		case CMT_STATUS_COVER_OPEN:
+			fprintf(stderr,"scanner cover is open");
+			break;
+		case CMT_STATUS_IO_ERROR:
+			fprintf(stderr,"error during device I/O");
+			break;
+		case CMT_STATUS_NO_MEM:
+			fprintf(stderr,"out of memory");
+			break;
+		case CMT_STATUS_ACCESS_DENIED:
+			fprintf(stderr,"access to resource has been denied");
+			break;
+		default:
+			break;
+	}
+	fprintf(stderr,"\n");
+}
+
+struct my_error_mgr {
+	struct jpeg_error_mgr errmgr;
+	jmp_buf escape;
+};
+
+#define INPUT_BUFFER_SIZE	4096
+typedef struct {
+	struct jpeg_source_mgr pub;
+
+	FILE *ctx;
+	unsigned char buffer[INPUT_BUFFER_SIZE];
+} my_source_mgr;
+/*
+ * Fill the input buffer --- called whenever buffer is emptied.
+ */
+static boolean fill_input_buffer (j_decompress_ptr cinfo)
+{
+	my_source_mgr * src = (my_source_mgr *) cinfo->src;
+	int nbytes;
+
+	nbytes = fread(src->buffer, 1, INPUT_BUFFER_SIZE, src->ctx);
+	if (nbytes <= 0) {
+		/* Insert a fake EOI marker */
+		src->buffer[0] = (unsigned char) 0xFF;
+		src->buffer[1] = (unsigned char) JPEG_EOI;
+		nbytes = 2;
+	}
+	src->pub.next_input_byte = src->buffer;
+	src->pub.bytes_in_buffer = nbytes;
+
+	return TRUE;
+}
+
+/*
+ * Skip data --- used to skip over a potentially large amount of
+ * uninteresting data (such as an APPn marker).
+ *
+ * Writers of suspendable-input applications must note that skip_input_data
+ * is not granted the right to give a suspension return.  If the skip extends
+ * beyond the data currently in the buffer, the buffer can be marked empty so
+ * that the next read will cause a fill_input_buffer call that can suspend.
+ * Arranging for additional bytes to be discarded before reloading the input
+ * buffer is the application writer's problem.
+ */
+static void skip_input_data (j_decompress_ptr cinfo, long num_bytes)
+{
+	my_source_mgr * src = (my_source_mgr *) cinfo->src;
+
+	/* Just a dumb implementation for now.	Could use fseek() except
+	 * it doesn't work on pipes.  Not clear that being smart is worth
+	 * any trouble anyway --- large skips are infrequent.
+	 */
+	if (num_bytes > 0) {
+		while (num_bytes > (long) src->pub.bytes_in_buffer) {
+			num_bytes -= (long) src->pub.bytes_in_buffer;
+			(void) src->pub.fill_input_buffer(cinfo);
+			/* note we assume that fill_input_buffer will never
+			 * return FALSE, so suspension need not be handled.
+			 */
+		}
+		src->pub.next_input_byte += (size_t) num_bytes;
+		src->pub.bytes_in_buffer -= (size_t) num_bytes;
+	}
+}
+
+
+/*
+ * Terminate source --- called by jpeg_finish_decompress
+ * after all data has been read.
+ */
+static void term_source (j_decompress_ptr cinfo)
+{
+	/* We don't actually need to do anything */
+	return;
+}
+/*
+ * Initialize source --- called by jpeg_read_header
+ * before any data is actually read.
+ */
+static void init_source (j_decompress_ptr cinfo)
+{
+	/* We don't actually need to do anything */
+	return;
+}
+/*
+ * Prepare for input from a stdio stream.
+ * The caller must have already opened the stream, and is responsible
+ * for closing it after finishing decompression.
+ */
+static void jpeg_RW_src (j_decompress_ptr cinfo, FILE *ctx)
+{
+  my_source_mgr *src;
+
+  /* The source object and input buffer are made permanent so that a series
+   * of JPEG images can be read from the same file by calling jpeg_stdio_src
+   * only before the first one.  (If we discarded the buffer at the end of
+   * one image, we'd likely lose the start of the next one.)
+   * This makes it unsafe to use this manager and a different source
+   * manager serially with the same JPEG object.  Caveat programmer.
+   */
+  if (cinfo->src == NULL) {	/* first time for this JPEG object? */
+    cinfo->src = (struct jpeg_source_mgr *)
+      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
+				  sizeof(my_source_mgr));
+    src = (my_source_mgr *) cinfo->src;
+  }
+
+  src = (my_source_mgr *) cinfo->src;
+  src->pub.init_source = init_source;
+  src->pub.fill_input_buffer = fill_input_buffer;
+  src->pub.skip_input_data = skip_input_data;
+  src->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */
+  src->pub.term_source = term_source;
+  src->ctx = ctx;
+  src->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */
+  src->pub.next_input_byte = NULL; /* until buffer loaded */
+}
+
+
+static void my_error_exit(j_common_ptr cinfo)
+{
+	struct my_error_mgr *err = (struct my_error_mgr *)cinfo->err;
+	longjmp(err->escape, 1);
+}
+
+static void output_no_message(j_common_ptr cinfo)
+{
+	/* do nothing */
+}
+/* Load a JPEG type image from an SDL datasource */
+CMT_Status IMG_LoadJPG_RW(canon_sane_t * handled,const char * filename)
+{
+	int start;
+	struct jpeg_decompress_struct cinfo;
+	JSAMPROW rowptr[1];
+	unsigned char * surface = NULL;
+	struct my_error_mgr jerr;
+	FILE * src = NULL;
+	int lineSize;
+	src = fopen(filename,"rb");
+	start = ftell(src);
+
+
+	/* Create a decompression structure and load the JPEG header */
+	cinfo.err = jpeg_std_error(&jerr.errmgr);
+	jerr.errmgr.error_exit = my_error_exit;
+	jerr.errmgr.output_message = output_no_message;
+	if(setjmp(jerr.escape)) {
+		/* If we get here, libjpeg found an error */
+		jpeg_destroy_decompress(&cinfo);
+		if ( surface != NULL ) {
+			free(surface);
+		}
+		fprintf(stderr,"JPEG loading error");
+		return CMT_STATUS_INVAL;
+	}
+
+	jpeg_create_decompress(&cinfo);
+	jpeg_RW_src(&cinfo, src);
+	jpeg_read_header(&cinfo, TRUE);
+
+
+		/* Set 24-bit RGB output */
+		cinfo.out_color_space = JCS_RGB;
+		cinfo.quantize_colors = FALSE;
+#ifdef FAST_JPEG
+		cinfo.scale_num   = 1;
+		cinfo.scale_denom = 1;
+		cinfo.dct_method = JDCT_FASTEST;
+		cinfo.do_fancy_upsampling = FALSE;
+#endif
+		jpeg_calc_output_dimensions(&cinfo);
+
+		/* Allocate an output surface to hold the image */
+		surface = malloc(cinfo.output_width * cinfo.output_height * 3);
+	if ( surface == NULL ) {
+		jpeg_destroy_decompress(&cinfo);
+		fseek(src, start, SEEK_SET);
+		fprintf(stderr,"Out of memory");
+		return CMT_STATUS_NO_MEM;
+	}
+
+	lineSize = cinfo.output_width * 3;
+	/* Decompress the image */
+	jpeg_start_decompress(&cinfo);
+	while ( cinfo.output_scanline < cinfo.output_height ) {
+		rowptr[0] = (JSAMPROW)surface + (lineSize * cinfo.output_scanline);//cinfo.output_width * 3;//cinfo.output_scanline * 3;
+		jpeg_read_scanlines(&cinfo, rowptr, (JDIMENSION) 1);
+	}
+
+	handled->img_data = surface;
+	handled->img_size = lineSize*cinfo.output_height;
+	handled->img_read = 0;
+	jpeg_finish_decompress(&cinfo);
+	jpeg_destroy_decompress(&cinfo);
+	fclose(src);
+	return CMT_STATUS_GOOD ;
+}
+
+void backend_error(SGMP_Data_Lite * data ,int *errCode){
+	// set backend error code.
+	*errCode = 0;
+	CIJSC_get_backend_error_code(errCode );
+	if( *errCode ) {
+		DBGMSG("backend errCode = %d\n", *errCode );
+		data->scan_result = CIJSC_SCANMAIN_SCAN_ERROR;
+	}
+
+	CIJSC_cancel();
+	// delete scanned file.
+}
+
+CMT_Status canon_sane_read(canon_sane_t * handled){
+
+	CMT_Status status = CMT_STATUS_GOOD;
+	unsigned char* buf  = NULL;
+	int readBytes = JPEGSCANBUFSIZE;
+	int len = 0;
+	FILE * file = NULL;
+	int total =0;
+	buf = (unsigned char *)calloc(JPEGSCANBUFSIZE,1);
+	if(!buf){
+		return CMT_STATUS_NO_MEM;
+	}
+	file = fopen(canonJpegDataTmp,"wb");
+	if(file == NULL){
+	return CMT_STATUS_INVAL;
+	}
+	while(status == CMT_STATUS_GOOD && !handled->cancel){
+		len = 0;
+		readBytes = JPEGSCANBUFSIZE;
+		status = CIJSC_read(buf,&readBytes);
+		len = fwrite(buf,1,readBytes,file);
+		total += len;
+	}
+	if(handled->cancel)
+		status = CMT_STATUS_CANCELLED;
+	fprintf(stderr,"total =  %d\n ",total);
+	fclose(file);
+	return status == CMT_STATUS_EOF ? CMT_STATUS_GOOD : status;
+}
+
+SANE_Status
+sane_init (SANE_Int * version_code, SANE_Auth_Callback authorize)
+{
+	fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+	CMT_Status status;
+	CNMSInt32 cnms_status = CNMS_NO_ERR;
+
+	UNUSED (authorize);
+
+	if (version_code != NULL)
+		*version_code = SANE_VERSION_CODE(1, 0, 0);
+	status = CIJSC_init((void*)NULL);
+	if (status != CMT_STATUS_GOOD)
+	{
+		show_canon_cmt_error(status);
+		return (SANE_Status)status;
+	}
+
+	cnms_status = KeepSettingCommonOpen();
+
+	if(cnms_status != CNMS_NO_ERR ){
+		/* show error dialog. */
+		CIJSC_exit();
+		fprintf(stderr,"FIN %s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		return SANE_STATUS_INVAL;
+	}
+
+	fprintf(stderr,"Fin %s, %s ,%d [%d]\n ",__FILE__,__FUNCTION__,__LINE__, status);
+	return SANE_STATUS_GOOD;//status;
+}
+
+
+
+void
+sane_exit (void){
+	fprintf(stderr," %s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+	CIJSC_exit();
+	fprintf(stderr,"FIN %s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+}
+
+
+const CANON_Device ** canon_get_device(int* num_scan,CMT_Status* status){
+	const CANON_Device **select_device_list = NULL;
+	int i = 0;
+	fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+
+	*status = CIJSC_get_devices( &select_device_list );
+	if ( *status != CMT_STATUS_GOOD ) {
+		CIJSC_exit();
+		KeepSettingCommonClose();
+	fprintf(stderr,"FIN %s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		return NULL;
+	}
+
+	//nombre de scanner
+	for(i=0; ; i++ ){
+		if( select_device_list[i] == NULL ){
+			break;
+		}
+	}
+
+	*num_scan = i;
+	if(i == 0){
+
+	fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		return NULL;
+	}
+	fprintf(stderr,"FIN %s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+	return select_device_list;
+}
+
+SANE_Status
+sane_get_devices (const SANE_Device *** device_list, SANE_Bool local_only)
+{
+	UNUSED (local_only);
+	fprintf(stderr,"%s, %s ,%d\n",__FILE__,__FUNCTION__,__LINE__);
+	int num_scan = 0;
+	const CANON_Device ** canon_list = NULL;
+	CMT_Status status;
+	if (!device_list){
+	fprintf(stderr,"FIN %s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		return SANE_STATUS_INVAL;
+	}
+
+	/* initialize selected device cache. */
+	num_scan = 0;
+	canon_list = canon_get_device(&num_scan,&status);
+	if(canon_list == NULL){
+	fprintf(stderr,"FIN %s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		return SANE_STATUS_NO_MEM;
+	}
+	if(status != CMT_STATUS_GOOD){
+	fprintf(stderr,"FIN %s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		return (SANE_Status)status;
+	}
+	dev_list = (const SANE_Device **) calloc (num_scan + 1, sizeof (*dev_list));
+
+	int i = 0;
+	for(;i< num_scan;i++){
+		dev_list[i] = convertFromCanonDev(canon_list[i]);
+	        dev_list[i+1] = NULL;
+	}
+
+	*device_list = dev_list;
+	fprintf(stderr,"FIN %s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+	return (dev_list) ? SANE_STATUS_GOOD : SANE_STATUS_NO_MEM;
+
+}
+
+static CMT_Status init_canon_options(canon_sane_t * handled){
+	unsigned long i;
+	SGMP_Data_Lite * data = NULL;
+	data = (SGMP_Data_Lite*)calloc(1,sizeof(SGMP_Data_Lite));
+	if(!data){
+		return CMT_STATUS_NO_MEM;
+	}
+
+	data->scan_scanmode = CIJSC_SCANMODE_PLATEN;
+	data->scan_source = CIJSC_SOURCE_DOCUMENT;
+	data->scan_color = CIJSC_COLOR_COLOR;
+	data->scan_format = CIJSC_FORMAT_JPEG;
+	data->scan_size = CIJSC_SIZE_A4;
+	data->scan_result = CIJSC_SCANMAIN_SCAN_FINISHED;
+
+	for ( i = 0; i < sizeof( sourceSize ) / sizeof( CIJSC_SIZE_TABLE ) ; i++ ) {
+		if ( sourceSize[i].id == data->scan_size ) {
+			break;
+		}
+	}
+	if ( i == ( sizeof( sourceSize ) / sizeof( CIJSC_SIZE_TABLE ) ) ) {
+		return CMT_STATUS_INVAL;
+	}
+
+	data->scan_res = resbit_list[5];
+	data->scan_w = sourceSize[i].right;
+	data->scan_h = sourceSize[i].bottom;
+//	data->scan_w = 638;//sourceSize[i].right;
+//	data->scan_h = 877;//sourceSize[i].bottom;
+	data->scanning_page = 1;
+	data->last_error_quit = CIJSC_ERROR_DLG_QUIT_FALSE;
+
+	handled->sgmp= *data;
+	SANE_Range x_range = {0,0,0},y_range = {0,0,0};
+	x_range.min = 0;
+	x_range.max = data->scan_res;
+	x_range.quant = 1;
+
+	y_range.min = 0;
+	y_range.max = data->scan_res;
+	y_range.quant = 1;
+	handled->x_range = x_range;
+	handled->y_range = y_range;
+	return CMT_STATUS_GOOD;
+}
+
+static CMT_Status
+init_options (canon_sane_t * s)
+{
+	int i;
+	CMT_Status status = CMT_STATUS_GOOD;
+
+	memset (s->opt, 0, sizeof (s->opt));
+	memset (s->val, 0, sizeof (s->val));
+
+	for (i = 0; i < NUM_OPTIONS; ++i)
+	{
+		s->opt[i].size = sizeof (SANE_Word);
+		s->opt[i].cap = SANE_CAP_SOFT_SELECT | SANE_CAP_SOFT_DETECT;
+	}
+
+	status = init_canon_options(s);
+	if(status != CMT_STATUS_GOOD){
+		return status;
+	}
+
+	s->opt[OPT_NUM_OPTS].title = SANE_TITLE_NUM_OPTIONS;
+	s->opt[OPT_NUM_OPTS].desc = SANE_DESC_NUM_OPTIONS;
+	s->opt[OPT_NUM_OPTS].type = SANE_TYPE_INT;
+	s->opt[OPT_NUM_OPTS].cap = SANE_CAP_SOFT_DETECT;
+	s->val[OPT_NUM_OPTS].w = NUM_OPTIONS;
+
+	/* "Mode" group: */
+	s->opt[OPT_MODE_GROUP].title = "Scan Mode";
+	s->opt[OPT_MODE_GROUP].desc = "";
+	s->opt[OPT_MODE_GROUP].type = SANE_TYPE_GROUP;
+	s->opt[OPT_MODE_GROUP].cap = 0;
+	s->opt[OPT_MODE_GROUP].constraint_type = SANE_CONSTRAINT_NONE;
+
+	s->opt[OPT_MODE].name = SANE_NAME_SCAN_MODE;
+	s->opt[OPT_MODE].title = SANE_TITLE_SCAN_MODE;
+	s->opt[OPT_MODE].desc = SANE_DESC_SCAN_MODE;
+	s->opt[OPT_MODE].type = SANE_TYPE_STRING;
+	s->opt[OPT_MODE].unit = SANE_UNIT_NONE;
+	s->opt[OPT_MODE].constraint_type = SANE_CONSTRAINT_STRING_LIST;
+	s->opt[OPT_MODE].constraint.string_list = mode_list;
+	s->val[OPT_MODE].s = strdup (mode_list[1]);
+	//s->sgmp.scan_color = s->val[OPT_MODE].s == SANE_VALUE_SCAN_MODE_COLOR ? CIJSC_COLOR_COLOR : CIJSC_COLOR_GRAY;
+
+	s->opt[OPT_RESOLUTION].name = SANE_NAME_SCAN_RESOLUTION;
+	s->opt[OPT_RESOLUTION].title = SANE_TITLE_SCAN_RESOLUTION;
+	s->opt[OPT_RESOLUTION].desc = SANE_DESC_SCAN_RESOLUTION;
+	s->opt[OPT_RESOLUTION].type = SANE_TYPE_INT;
+	s->opt[OPT_RESOLUTION].unit = SANE_UNIT_DPI;
+	/* TODO: Build the constraints on resolution in a smart way */
+	s->opt[OPT_RESOLUTION].constraint_type = SANE_CONSTRAINT_WORD_LIST;
+	s->opt[OPT_RESOLUTION].constraint.word_list = resbit_list;
+	s->val[OPT_RESOLUTION].w = s->sgmp.scan_res;
+
+	s->opt[OPT_PREVIEW].name = SANE_NAME_PREVIEW;
+	s->opt[OPT_PREVIEW].title = SANE_TITLE_PREVIEW;
+	s->opt[OPT_PREVIEW].desc = SANE_DESC_PREVIEW;
+	s->opt[OPT_PREVIEW].cap = SANE_CAP_SOFT_DETECT | SANE_CAP_SOFT_SELECT;
+	s->opt[OPT_PREVIEW].type = SANE_TYPE_BOOL;
+	s->val[OPT_PREVIEW].w = SANE_FALSE;
+
+	/* "Geometry" group: */
+	s->opt[OPT_GEOMETRY_GROUP].title = "Geometry";
+	s->opt[OPT_GEOMETRY_GROUP].desc = "";
+	s->opt[OPT_GEOMETRY_GROUP].type = SANE_TYPE_GROUP;
+	s->opt[OPT_GEOMETRY_GROUP].cap = SANE_CAP_ADVANCED;
+	s->opt[OPT_GEOMETRY_GROUP].constraint_type = SANE_CONSTRAINT_NONE;
+
+	/* top-left x */
+	s->opt[OPT_TL_X].name = SANE_NAME_SCAN_TL_X;
+	s->opt[OPT_TL_X].title = SANE_TITLE_SCAN_TL_X;
+	s->opt[OPT_TL_X].desc = SANE_DESC_SCAN_TL_X;
+	s->opt[OPT_TL_X].type = SANE_TYPE_FIXED;
+	s->opt[OPT_TL_X].unit = SANE_UNIT_MM;
+	s->opt[OPT_TL_X].constraint_type = SANE_CONSTRAINT_RANGE;
+	s->opt[OPT_TL_X].constraint.range = &s->x_range;
+	s->val[OPT_TL_X].w = 0;
+
+	/* top-left y */
+	s->opt[OPT_TL_Y].name = SANE_NAME_SCAN_TL_Y;
+	s->opt[OPT_TL_Y].title = SANE_TITLE_SCAN_TL_Y;
+	s->opt[OPT_TL_Y].desc = SANE_DESC_SCAN_TL_Y;
+	s->opt[OPT_TL_Y].type = SANE_TYPE_FIXED;
+	s->opt[OPT_TL_Y].unit = SANE_UNIT_MM;
+	s->opt[OPT_TL_Y].constraint_type = SANE_CONSTRAINT_RANGE;
+	s->opt[OPT_TL_Y].constraint.range = &s->y_range;
+	s->val[OPT_TL_Y].w = 0;
+
+	/* bottom-right x */
+	s->opt[OPT_BR_X].name = SANE_NAME_SCAN_BR_X;
+	s->opt[OPT_BR_X].title = SANE_TITLE_SCAN_BR_X;
+	s->opt[OPT_BR_X].desc = SANE_DESC_SCAN_BR_X;
+	s->opt[OPT_BR_X].type = SANE_TYPE_FIXED;
+	s->opt[OPT_BR_X].unit = SANE_UNIT_MM;
+	s->opt[OPT_BR_X].constraint_type = SANE_CONSTRAINT_RANGE;
+	s->opt[OPT_BR_X].constraint.range = &s->x_range;
+	s->val[OPT_BR_X].w =s->sgmp.scan_res;
+
+	/* bottom-right y */
+	s->opt[OPT_BR_Y].name = SANE_NAME_SCAN_BR_Y;
+	s->opt[OPT_BR_Y].title = SANE_TITLE_SCAN_BR_Y;
+	s->opt[OPT_BR_Y].desc = SANE_DESC_SCAN_BR_Y;
+	s->opt[OPT_BR_Y].type = SANE_TYPE_FIXED;
+	s->opt[OPT_BR_Y].unit = SANE_UNIT_MM;
+	s->opt[OPT_BR_Y].constraint_type = SANE_CONSTRAINT_RANGE;
+	s->opt[OPT_BR_Y].constraint.range = &s->y_range;
+	s->val[OPT_BR_Y].w = s->sgmp.scan_res;
+
+	return status;
+
+}
+
+SANE_Status
+sane_open (SANE_String_Const name, SANE_Handle * h){
+	fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+
+	canon_sane_t *  handled = NULL;
+	CANON_Device dev;
+	CMT_Status status = CMT_STATUS_INVAL;
+
+	if(!name){
+		fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		return SANE_STATUS_INVAL;
+	}
+
+	status = CIJSC_open2((char*)name,&dev);
+	if(status != CMT_STATUS_GOOD){
+	fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		return(SANE_Status)status;
+	}
+
+
+	handled = (canon_sane_t*)malloc(sizeof(canon_sane_t));
+	if(!handled){
+	fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		return SANE_STATUS_NO_MEM;
+	}
+
+
+	status = init_options(handled);
+	if(status != CMT_STATUS_GOOD){
+	fprintf(stderr,"mode : %s",handled->val[OPT_MODE].s);
+		return(SANE_Status)status;
+	}
+
+	handled->dev = dev;
+	handled->cancel = SANE_FALSE;
+	handled->write_scan_data = SANE_FALSE;
+	handled->decompress_scan_data = SANE_FALSE;
+	handled->end_read = SANE_FALSE;
+	fprintf(stderr,"FIN %s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+	*h = handled;
+	return SANE_STATUS_GOOD;
+
+}
+
+void sane_cancel(SANE_Handle h){
+	canon_sane_t* handled = h;
+	handled->cancel = SANE_TRUE;
+	CIJSC_cancel();
+}
+
+void
+sane_close (SANE_Handle h){
+
+	fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+	CIJSC_close( );
+	if(h){
+		free(h);
+		h = NULL;
+	}
+	KeepSettingCommonClose();
+	fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+	UNUSED(h);
+}
+
+const SANE_Option_Descriptor *
+sane_get_option_descriptor(SANE_Handle h, SANE_Int n){
+	canon_sane_t *s = h;
+	if ((unsigned) n >= NUM_OPTIONS)
+		return NULL;
+	fprintf(stderr,"FIN %s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+	return s->opt + n;
+}
+
+SANE_Status
+sane_control_option (SANE_Handle h, SANE_Int n,
+		     SANE_Action a, void *v, SANE_Int * i)
+{
+	fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+	canon_sane_t * handled = h;
+
+	if (i)
+		*i = 0;
+
+	if (n >= NUM_OPTIONS || n < 0)
+		return SANE_STATUS_INVAL;
+
+	if(a == SANE_ACTION_GET_VALUE){
+
+		switch(n){
+			case OPT_NUM_OPTS:
+			case OPT_MODE_GROUP:
+			case OPT_MODE:
+			case OPT_RESOLUTION:
+			case OPT_TL_X:
+			case OPT_TL_Y:
+			case OPT_BR_X:
+			case OPT_BR_Y:
+			case OPT_PREVIEW:
+				*(SANE_Word *) v = handled->val[n].w;
+				fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+				return SANE_STATUS_GOOD;
+			default:break;
+		}
+		fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		return SANE_STATUS_GOOD;
+	}
+
+	if(a == SANE_ACTION_SET_VALUE){
+
+		switch(n){
+			case OPT_NUM_OPTS:
+			case OPT_MODE_GROUP:
+			case OPT_MODE:
+			case OPT_RESOLUTION:
+			case OPT_TL_X:
+			case OPT_TL_Y:
+			case OPT_BR_X:
+			case OPT_BR_Y:
+			case OPT_PREVIEW:
+				handled->val[n].w = *(SANE_Word *) v;
+				fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+				return SANE_STATUS_GOOD;
+			default:break;
+		}
+		fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		return SANE_STATUS_GOOD;
+	}
+	fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+	return SANE_STATUS_GOOD;
+}
+
+
+
+
+SANE_Status
+sane_start (SANE_Handle h){
+	int errCode = 0;
+	canon_sane_t* handled = h;
+	CMT_Status status = CMT_STATUS_INVAL;
+	CANON_ScanParam param;
+	memset( &param, 0, sizeof(param) );
+
+	fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+
+	param.XRes			= handled->sgmp.scan_res;
+	param.YRes			= handled->sgmp.scan_res;
+	param.Left			= 0;
+	param.Top			= 0;
+	param.Right			= handled->sgmp.scan_w;
+	param.Bottom		= handled->sgmp.scan_h;
+	param.ScanMode		= ( handled->sgmp.scan_color == CIJSC_COLOR_COLOR ) ? 4 : 2;
+	param.ScanMethod	= ( handled->sgmp.scan_scanmode == CIJSC_SCANMODE_ADF_D_S ) ? CIJSC_SCANMODE_ADF_D_L : handled->sgmp.scan_scanmode;
+	param.opts.p1_0		= 0;
+	param.opts.p2_0		= 0;
+	param.opts.p3_3		= 3;
+	param.opts.DocumentType		= handled->sgmp.scan_source + 1;
+	param.opts.p4_0		= 0;
+	param.opts.p5_0		= 0;
+	param.opts.p6_1		= 1;
+
+	handled->param = param;
+
+SCAN_START:
+
+	/* scan start*/
+
+	status = CIJSC_start( &param );
+	if(status  != CMT_STATUS_GOOD ){
+		handled->sgmp.last_error_quit = status;
+		fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		/* ADF : check status. */
+		if ( param.ScanMethod != CIJSC_SCANMODE_PLATEN &&  status == CMT_STATUS_NO_DOCS ) {
+			/* no paper */
+			fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+			if( handled->sgmp.scanning_page == 1 ) {
+				CIJSC_UI_error_show( &(handled->sgmp) );
+				fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+				if(handled->sgmp.last_error_quit == CIJSC_VALUE_OK){
+					fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+					goto SCAN_START;
+				}
+				else {
+					/* scan canceled.*/
+					fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+					/* delete disused file. */
+					DBGMSG("CIJSC_cancel->\n");
+					CIJSC_cancel();
+					return SANE_STATUS_CANCELLED;
+				}
+			}else {
+				/* delete disused file.*/
+				fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+				DBGMSG("CIJSC_cancel->\n");
+				CIJSC_cancel();
+				return SANE_STATUS_CANCELLED;
+			}
+		}
+		DBGMSG("Error in CIJSC_start \n");
+		backend_error(&(handled->sgmp),&errCode);
+		fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		return SANE_STATUS_CANCELLED;
+	}
+
+	fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+	return SANE_STATUS_GOOD;
+
+}
+
+SANE_Status
+sane_get_parameters (SANE_Handle h, SANE_Parameters * p)//voir avec CIJSC_get_parameters
+{
+
+	canon_sane_t* handled = h;
+	CANON_SCANDATA *scandata = NULL;
+	scandata = (CANON_SCANDATA *)malloc(sizeof(CANON_SCANDATA));
+	SANE_Parameters ps;
+	SANE_String val = handled->val[OPT_MODE].s;
+	CMT_Status status = CMT_STATUS_GOOD;
+
+	int errCode = 0;
+	fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+	fprintf(stderr,"w = %d, h = %d\n",handled->sgmp.scan_w, handled->sgmp.scan_h);
+	/* get parameters */
+
+	if(canon_get_parameters( scandata, (void *)NULL ) < 0){
+		backend_error(&(handled->sgmp),&errCode);
+		fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		return SANE_STATUS_CANCELLED;
+	}
+
+	ps.pixels_per_line = scandata->pixels_per_line;
+	ps.bytes_per_line = handled->sgmp.scan_color == CIJSC_COLOR_COLOR ? scandata->bytes_per_line : scandata->bytes_per_line*3;
+	ps.lines = scandata->lines;//-1;
+	//	ps.lines = -1;
+
+	fprintf(stderr,"ps.pixels_per_line = %d, ps.bytes_per_line = %d, ps.lines = %d\n",ps.pixels_per_line, ps.bytes_per_line, ps.lines);
+
+	ps.depth = 8;//8
+	ps.last_frame = SANE_TRUE;
+
+	fprintf(stderr,"mode : %s\n",val);
+	fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+
+	if(!strcmp (val, SANE_VALUE_SCAN_MODE_COLOR)){
+		fprintf(stderr,"================================================ >scan couleur \n");
+
+		fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		ps.format = SANE_FRAME_RGB;
+	}
+	else{//SANE_VALUE_SCAN_MODE_GRAY,
+		fprintf(stderr,"================================================ >scan noir et blanc \n");
+
+		fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		ps.format = SANE_FRAME_GRAY;
+	}
+	*p = ps;
+	fprintf(stderr,"p->format = %d, ps.format = %d\n",p->format,ps.format);
+
+
+	fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+	return SANE_STATUS_GOOD;
+}
+
+
+
+SANE_Status
+sane_read (SANE_Handle h, SANE_Byte * buf, SANE_Int maxlen, SANE_Int * len){
+	canon_sane_t * handled = h;
+	SANE_Status status = SANE_STATUS_GOOD;
+	long readbyte;
+	if(!handled|!buf|!len){
+		return SANE_STATUS_INVAL;
+		fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+	}
+	if(handled->cancel)
+		return SANE_STATUS_CANCELLED;
+	//lire toute les donnée du scanner les placé dans un fichier tmp
+	if(!handled->write_scan_data){
+		fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		status = (SANE_Status)canon_sane_read(handled);
+		if(status != SANE_STATUS_GOOD){
+			fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+			return status;
+		}
+		else{
+			handled->write_scan_data = SANE_TRUE;
+		}
+	}
+
+	if(!handled->decompress_scan_data){
+		status = (SANE_Status)IMG_LoadJPG_RW(handled, canonJpegDataTmp);
+		if(status != SANE_STATUS_GOOD){
+			fprintf(stderr,"erreur : %s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+			return status;
+		}
+		handled->decompress_scan_data = SANE_TRUE;
+		fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+	}
+	if(handled->img_data == NULL){
+
+		fprintf(stderr,"%s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+		return SANE_STATUS_INVAL;
+	}
+	if(!handled->end_read){
+		readbyte = min((handled->img_size - handled->img_read), maxlen);
+		memcpy(buf,handled->img_data+handled->img_read,readbyte);
+		handled->img_read += readbyte;
+		*len = readbyte;
+		if(handled->img_read == handled->img_size){
+			handled->end_read = SANE_TRUE;
+		}
+		else if(handled->img_read > handled->img_size){
+			fprintf(stderr,"%s, %s ,%ld, %ld\n ",__FILE__,__FUNCTION__,handled->img_size,handled->img_read);
+			*len = 0;
+			handled->end_read = SANE_TRUE;
+			free(handled->img_data);
+			handled->img_data = NULL;
+			fprintf(stderr," %s, %s ,%d\n ",__FILE__,__FUNCTION__,__LINE__);
+			return SANE_STATUS_INVAL;
+		}
+	}
+	else{
+
+		*len = 0;
+		free(handled->img_data);
+		handled->img_data = NULL;
+		return SANE_STATUS_EOF;
+	}
+	return SANE_STATUS_GOOD;
+}
+
+SANE_Status
+sane_get_select_fd (SANE_Handle h, SANE_Int * fd)
+{
+	h= h;
+	fd =fd;
+	return SANE_STATUS_UNSUPPORTED;
+}
+
+SANE_Status
+sane_set_io_mode(SANE_Handle handle,
+			SANE_Bool non_blocking)
+{
+	return SANE_STATUS_UNSUPPORTED;
+}
+
Index: scangearmp2/scangearmp2/src/sane/canon_pixma.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ scangearmp2/scangearmp2/src/sane/canon_pixma.h	2017-08-09 11:33:56.413553741 +0200
@@ -0,0 +1,39 @@
+#ifndef __CANON_PIXMA_H__
+#define __CANON_PIXMA_H__
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include "errors.h"
+#include "errordlg.h"
+#include "cnmstype.h"
+#include "cnmsfunc.h"
+#include "support.h"
+#include "canon_mfp_tools.h"
+#include "keep_setting.h"
+#include "file_control.h"
+//#include <glib.h>
+//#include "usr/include/glib-2.0/glib.h"
+
+#ifndef BACKEND_NAME
+#define BACKEND_NAME canon_pixma
+#endif
+
+enum canon_sane_Option
+{
+	OPT_NUM_OPTS = 0,
+	OPT_MODE_GROUP,
+	OPT_MODE,
+	OPT_RESOLUTION,
+	OPT_PREVIEW,
+
+	OPT_GEOMETRY_GROUP,
+	OPT_TL_X,
+	OPT_TL_Y,
+	OPT_BR_X,
+	OPT_BR_Y,
+	/* must come last: */
+	NUM_OPTIONS
+};
+
+#endif // __CANON_PIXMA_H__
Index: scangearmp2/scangearmp2/src/sane/errordlg.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ scangearmp2/scangearmp2/src/sane/errordlg.c	2017-08-09 11:34:18.713552822 +0200
@@ -0,0 +1,191 @@
+/*
+ *  ScanGear MP for Linux
+ *  Copyright CANON INC. 2007-2016
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * NOTE:
+ *  - As a special exception, this program is permissible to link with the
+ *    libraries released as the binary modules.
+ *  - If you write modifications of your own for these programs, it is your
+ *    choice whether to permit this exception to apply to your modifications.
+ *    If you do not wish that, delete this exception.
+*/
+
+#ifndef	_ERRORDLG_C_
+#define	_ERRORDLG_C_
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+
+//#include <gtk/gtk.h>
+
+#include "support.h"
+#include "cnmsstrings.h"
+#include "errors.h"
+
+#include "errordlg.h"
+
+/* error dialog message type */
+enum{
+	CIJSC_ERROR_NO_DEV = 0,
+	CIJSC_ERROR_CONNECT_FAILED,
+	CIJSC_ERROR_DEVICE_CANCEL,
+	CIJSC_ERROR_DEVICE_BUSY,
+	CIJSC_ERROR_NO_PAPER,
+	CIJSC_ERROR_DEVICE_ADF_CANCEL,
+	CIJSC_ERROR_DEVICE_OTHER,
+	CIJSC_ERROR_SAVE_NO_FILE_NAME,
+	CIJSC_ERROR_SAVE_OVERWRITE,
+	CIJSC_ERROR_SAVE_NO_ACCESS,
+	CIJSC_ERROR_SAVE_INVALID_DIR,
+	CIJSC_ERROR_SAVE_OTHER,
+	CIJSC_ERROR_SAVE_DISK_FULL,
+	CIJSC_ERROR_INTERNAL,
+};
+
+enum{
+	CIJSC_ERROR_DLG_TYPE_OK = 0,
+	CIJSC_ERROR_DLG_TYPE_OK_CANCEL,
+};
+
+typedef struct {
+	const int		id;
+	const char		*msg;
+	const int		type;
+	const int		quit;
+} CIJSC_ERROR_MSG_TABLE;
+
+static CIJSC_ERROR_MSG_TABLE error_msg_table[] = {
+	{ CIJSC_ERROR_NO_DEV,			STR_CNMS_LS_010_07,		CIJSC_ERROR_DLG_TYPE_OK, CIJSC_ERROR_DLG_QUIT_FALSE, },
+	{ CIJSC_ERROR_CONNECT_FAILED,	STR_CNMS_LS_010_05,		CIJSC_ERROR_DLG_TYPE_OK, CIJSC_ERROR_DLG_QUIT_TRUE, },
+	{ CIJSC_ERROR_DEVICE_CANCEL,	STR_CNMS_LS_010_01,		CIJSC_ERROR_DLG_TYPE_OK, CIJSC_ERROR_DLG_QUIT_FALSE, },
+	{ CIJSC_ERROR_DEVICE_BUSY,		STR_CNMS_LS_010_03,		CIJSC_ERROR_DLG_TYPE_OK, CIJSC_ERROR_DLG_QUIT_TRUE, },
+	{ CIJSC_ERROR_NO_PAPER,			STR_CNMS_LS_010_08,		CIJSC_ERROR_DLG_TYPE_OK_CANCEL, CIJSC_ERROR_DLG_QUIT_FALSE, },
+	{ CIJSC_ERROR_DEVICE_ADF_CANCEL,STR_CNMS_LS_010_02,		CIJSC_ERROR_DLG_TYPE_OK, CIJSC_ERROR_DLG_QUIT_FALSE, },
+	{ CIJSC_ERROR_DEVICE_OTHER,		STR_CNMS_LS_010_04,		CIJSC_ERROR_DLG_TYPE_OK, CIJSC_ERROR_DLG_QUIT_TRUE, },
+	{ CIJSC_ERROR_SAVE_NO_FILE_NAME,STR_CNMS_LS_008_03,		CIJSC_ERROR_DLG_TYPE_OK, CIJSC_ERROR_DLG_QUIT_FALSE, },
+	{ CIJSC_ERROR_SAVE_OVERWRITE,	STR_CNMS_LS_008_04,		CIJSC_ERROR_DLG_TYPE_OK_CANCEL, CIJSC_ERROR_DLG_QUIT_FALSE, },
+	{ CIJSC_ERROR_SAVE_NO_ACCESS,	STR_CNMS_LS_008_05,		CIJSC_ERROR_DLG_TYPE_OK, CIJSC_ERROR_DLG_QUIT_FALSE, },
+	{ CIJSC_ERROR_SAVE_INVALID_DIR,	STR_CNMS_LS_008_06,		CIJSC_ERROR_DLG_TYPE_OK, CIJSC_ERROR_DLG_QUIT_FALSE, },
+	{ CIJSC_ERROR_SAVE_OTHER,		STR_CNMS_LS_008_07,		CIJSC_ERROR_DLG_TYPE_OK, CIJSC_ERROR_DLG_QUIT_FALSE, },
+	{ CIJSC_ERROR_SAVE_DISK_FULL,	STR_CNMS_LS_010_06,		CIJSC_ERROR_DLG_TYPE_OK, CIJSC_ERROR_DLG_QUIT_TRUE, },
+	{ CIJSC_ERROR_INTERNAL,			STR_CNMS_LS_010_09,		CIJSC_ERROR_DLG_TYPE_OK, CIJSC_ERROR_DLG_QUIT_TRUE, },
+	{ -1,	NULL, -1, -1, },
+};
+
+
+typedef struct {
+	const int		code;
+	const int		id;
+} CIJSC_ERROR_INDEX_TABLE;
+
+static CIJSC_ERROR_INDEX_TABLE error_index_table[] = {
+	{ BERRCODE_CONNECT_NO_DEVICE,			CIJSC_ERROR_NO_DEV },
+	{ BERRCODE_CANCELD_BY_STOP,				CIJSC_ERROR_DEVICE_CANCEL },
+	{ BERRCODE_SCANNER_BUSY_COPYING,		CIJSC_ERROR_DEVICE_OTHER },
+	{ BERRCODE_SCANNER_BUSY_PRINTING,		CIJSC_ERROR_DEVICE_OTHER },
+	{ BERRCODE_SCANNER_BUSY_PRINTERMNT,		CIJSC_ERROR_DEVICE_OTHER },
+	{ 101,									CIJSC_ERROR_CONNECT_FAILED },
+	{ BERRCODE_CONNECT_FAILED,				CIJSC_ERROR_CONNECT_FAILED },
+	{ 162,									CIJSC_ERROR_CONNECT_FAILED },
+	{ 172,									CIJSC_ERROR_CONNECT_FAILED },
+	{ 173,									CIJSC_ERROR_CONNECT_FAILED },
+	{ ERR_CODE_ENOSPC,						CIJSC_ERROR_SAVE_DISK_FULL },
+	{ ERR_CODE_INT,							CIJSC_ERROR_INTERNAL },
+	{ BERRCODE_DEVICE_NOT_AVAILABLE,		CIJSC_ERROR_DEVICE_BUSY },
+	{ BERRCODE_DEVICE_INITIALIZE,			CIJSC_ERROR_DEVICE_BUSY },
+	{ BERRCODE_SYSTEM,						CIJSC_ERROR_DEVICE_OTHER },
+	{ BERRCODE_CANCELED_ADF,				CIJSC_ERROR_DEVICE_ADF_CANCEL },
+	{ BERRCODE_ADF_JAM,						CIJSC_ERROR_DEVICE_OTHER },
+	{ BERRCODE_ADF_COVER_OPEN,				CIJSC_ERROR_DEVICE_OTHER },
+	{ BERRCODE_ADF_NO_PAPER,				CIJSC_ERROR_NO_PAPER },
+	{ BERRCODE_ADF_PAPER_FEED,				CIJSC_ERROR_DEVICE_OTHER },
+	{ BERRCODE_ADF_MISMATCH_SIZE,			CIJSC_ERROR_DEVICE_OTHER },
+	{ BERRCODE_DEVICE_NOT_AVAILABLE_LAN,	CIJSC_ERROR_CONNECT_FAILED },
+	{ BERRCODE_DEVICE_NOT_AVAILABLE_LAN_LOCK,	CIJSC_ERROR_CONNECT_FAILED },
+	{ BERRCODE_SCANNER_LOCKED,					CIJSC_ERROR_DEVICE_OTHER },
+	{ BERRCODE_SCANNER_CONNECT_FAILED_USB,		CIJSC_ERROR_CONNECT_FAILED },
+	{ BERRCODE_SCANNER_CONNECT_FAILED_LAN,		CIJSC_ERROR_CONNECT_FAILED },
+
+	{ BERRCODE_SAVE_NO_FILE_NAME,		CIJSC_ERROR_SAVE_NO_FILE_NAME },
+	{ BERRCODE_SAVE_OVERWRITE,			CIJSC_ERROR_SAVE_OVERWRITE },
+	{ BERRCODE_SAVE_NO_ACCESS,			CIJSC_ERROR_SAVE_NO_ACCESS },
+	{ BERRCODE_SAVE_INVALID_DIR,		CIJSC_ERROR_SAVE_INVALID_DIR },
+	{ BERRCODE_SAVE_OTHER,				CIJSC_ERROR_SAVE_OTHER },
+};
+
+
+
+int CIJSC_UI_error_show( SGMP_Data_Lite *data )
+{
+	int		index_id, index_mes;
+	int		ret = -1;
+	int		errorCode = 0;
+
+	DBGMSG("->\n");
+
+	if ( lastIOErrCode ) {
+		errorCode = -lastIOErrCode;
+		if( errorCode != ERR_CODE_ENOSPC ) {
+			errorCode = ERR_CODE_INT;
+		}
+	}
+	else if ( lastModuleErrCode ) {
+		errorCode = ERR_CODE_INT;
+	}
+	else {
+		errorCode = lastBackendErrCode;
+	}
+	DBGMSG("errorCode = %d\n", errorCode );
+	data->last_error_quit = CIJSC_ERROR_DLG_QUIT_FALSE;
+
+	/* error occurred. */
+	if ( errorCode ) {
+	/* get error id. */
+		for( index_id = 0; (unsigned long)index_id < sizeof( error_index_table ) / sizeof( CIJSC_ERROR_INDEX_TABLE ) ; index_id++ ) {
+			if ( error_index_table[index_id].code == errorCode ) {
+				break;
+			}
+		}
+		DBGMSG("index_id = %d\n", index_id );
+		if ( index_id == ( sizeof( error_index_table ) / sizeof( CIJSC_ERROR_INDEX_TABLE ) ) ) {
+			goto _EXIT;
+		}
+		/* get error message. */
+		for( index_mes = 0; error_msg_table[index_mes].id >= 0 ; index_mes++ ) {
+			if ( error_msg_table[index_mes].id == error_index_table[index_id].id ) {
+				break;
+			}
+		}
+		DBGMSG("index_mes = %d\n", index_mes );
+		if ( error_msg_table[index_mes].id < 0 ) {
+			goto _EXIT;
+		}
+
+		ret = error_msg_table[index_mes].quit;
+		data->last_error_quit = ret;
+
+	}
+_EXIT:
+	lastBackendErrCode = 0;
+
+	return ret;
+}
+
+
+#endif	/* _ERRORDLG_C_ */
+
Index: scangearmp2/scangearmp2/src/sane/errordlg.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ scangearmp2/scangearmp2/src/sane/errordlg.h	2017-08-09 11:28:34.000000000 +0200
@@ -0,0 +1,43 @@
+/*
+ *  ScanGear MP for Linux
+ *  Copyright CANON INC. 2007-2016
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * NOTE:
+ *  - As a special exception, this program is permissible to link with the
+ *    libraries released as the binary modules.
+ *  - If you write modifications of your own for these programs, it is your
+ *    choice whether to permit this exception to apply to your modifications.
+ *    If you do not wish that, delete this exception.
+*/
+
+#ifndef	_ERRORDLG_H_
+#define	_ERRORDLG_H_
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+
+#include "support.h"
+
+int CIJSC_UI_error_show( SGMP_Data_Lite *data );
+
+
+#endif	/* _ERRORDLG_H_ */
+
+
+
+
Index: scangearmp2/scangearmp2/src/sane/sane.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ scangearmp2/scangearmp2/src/sane/sane.h	2017-08-09 11:28:34.000000000 +0200
@@ -0,0 +1,213 @@
+/* sane - Scanner Access Now Easy.
+   Copyright (C) 1997-1999 David Mosberger-Tang and Andreas Beck
+   This file is part of the SANE package.
+
+   This file is in the public domain.  You may use and modify it as
+   you see fit, as long as this copyright message is included and
+   that there is an indication as to what modifications have been
+   made (if any).
+
+   SANE is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.
+
+   This file declares SANE application interface.  See the SANE
+   standard for a detailed explanation of the interface.  */
+#ifndef sane_h
+#define sane_h
+
+#define SANE_CURRENT_MAJOR	1
+
+#define SANE_VERSION_CODE(major, minor, build)	\
+  (  (((SANE_Word) (major) &   0xff) << 24)	\
+   | (((SANE_Word) (minor) &   0xff) << 16)	\
+   | (((SANE_Word) (build) & 0xffff) <<  0))
+
+#define SANE_VERSION_MAJOR(code)	((((SANE_Word)(code)) >> 24) &   0xff)
+#define SANE_VERSION_MINOR(code)	((((SANE_Word)(code)) >> 16) &   0xff)
+#define SANE_VERSION_BUILD(code)	((((SANE_Word)(code)) >>  0) & 0xffff)
+
+#define SANE_FALSE	0
+#define SANE_TRUE	1
+
+typedef unsigned char SANE_Byte;
+typedef int SANE_Word;
+typedef SANE_Word SANE_Bool;
+typedef SANE_Word SANE_Int;
+typedef char SANE_Char;
+typedef SANE_Char *SANE_String;
+typedef const SANE_Char *SANE_String_Const;
+typedef void *SANE_Handle;
+typedef SANE_Word SANE_Fixed;
+
+#define SANE_FIXED_SCALE_SHIFT	16
+#define SANE_FIX(v)	((SANE_Word) ((v) * (1 << SANE_FIXED_SCALE_SHIFT)))
+#define SANE_UNFIX(v)	((double)(v) / (1 << SANE_FIXED_SCALE_SHIFT))
+
+typedef enum
+  {
+    SANE_STATUS_GOOD = 0,	/* everything A-OK */
+    SANE_STATUS_UNSUPPORTED,	/* operation is not supported */
+    SANE_STATUS_CANCELLED,	/* operation was cancelled */
+    SANE_STATUS_DEVICE_BUSY,	/* device is busy; try again later */
+    SANE_STATUS_INVAL,		/* data is invalid (includes no dev at open) */
+    SANE_STATUS_EOF,		/* no more data available (end-of-file) */
+    SANE_STATUS_JAMMED,		/* document feeder jammed */
+    SANE_STATUS_NO_DOCS,	/* document feeder out of documents */
+    SANE_STATUS_COVER_OPEN,	/* scanner cover is open */
+    SANE_STATUS_IO_ERROR,	/* error during device I/O */
+    SANE_STATUS_NO_MEM,		/* out of memory */
+    SANE_STATUS_ACCESS_DENIED	/* access to resource has been denied */
+  }
+SANE_Status;
+
+typedef enum
+  {
+    SANE_TYPE_BOOL = 0,
+    SANE_TYPE_INT,
+    SANE_TYPE_FIXED,
+    SANE_TYPE_STRING,
+    SANE_TYPE_BUTTON,
+    SANE_TYPE_GROUP
+  }
+SANE_Value_Type;
+
+typedef enum
+  {
+    SANE_UNIT_NONE = 0,		/* the value is unit-less (e.g., # of scans) */
+    SANE_UNIT_PIXEL,		/* value is number of pixels */
+    SANE_UNIT_BIT,		/* value is number of bits */
+    SANE_UNIT_MM,		/* value is millimeters */
+    SANE_UNIT_DPI,		/* value is resolution in dots/inch */
+    SANE_UNIT_PERCENT,		/* value is a percentage */
+    SANE_UNIT_MICROSECOND	/* value is micro seconds */
+  }
+SANE_Unit;
+
+typedef struct
+  {
+    SANE_String_Const name;	/* unique device name */
+    SANE_String_Const vendor;	/* device vendor string */
+    SANE_String_Const model;	/* device model name */
+    SANE_String_Const type;	/* device type (e.g., "flatbed scanner") */
+  }
+SANE_Device;
+
+#define SANE_CAP_SOFT_SELECT		(1 << 0)
+#define SANE_CAP_HARD_SELECT		(1 << 1)
+#define SANE_CAP_SOFT_DETECT		(1 << 2)
+#define SANE_CAP_EMULATED		(1 << 3)
+#define SANE_CAP_AUTOMATIC		(1 << 4)
+#define SANE_CAP_INACTIVE		(1 << 5)
+#define SANE_CAP_ADVANCED		(1 << 6)
+#define SANE_CAP_ALWAYS_SETTABLE	(1 << 7)
+
+#define SANE_OPTION_IS_ACTIVE(cap)	(((cap) & SANE_CAP_INACTIVE) == 0)
+#define SANE_OPTION_IS_SETTABLE(cap)	(((cap) & SANE_CAP_SOFT_SELECT) != 0)
+
+#define SANE_INFO_INEXACT		(1 << 0)
+#define SANE_INFO_RELOAD_OPTIONS	(1 << 1)
+#define SANE_INFO_RELOAD_PARAMS		(1 << 2)
+
+typedef enum
+  {
+    SANE_CONSTRAINT_NONE = 0,
+    SANE_CONSTRAINT_RANGE,
+    SANE_CONSTRAINT_WORD_LIST,
+    SANE_CONSTRAINT_STRING_LIST
+  }
+SANE_Constraint_Type;
+
+typedef struct
+  {
+    SANE_Word min;		/* minimum (element) value */
+    SANE_Word max;		/* maximum (element) value */
+    SANE_Word quant;		/* quantization value (0 if none) */
+  }
+SANE_Range;
+
+typedef struct
+  {
+    SANE_String_Const name;	/* name of this option (command-line name) */
+    SANE_String_Const title;	/* title of this option (single-line) */
+    SANE_String_Const desc;	/* description of this option (multi-line) */
+    SANE_Value_Type type;	/* how are values interpreted? */
+    SANE_Unit unit;		/* what is the (physical) unit? */
+    SANE_Int size;
+    SANE_Int cap;		/* capabilities */
+
+    SANE_Constraint_Type constraint_type;
+    union
+      {
+	const SANE_String_Const *string_list;	/* NULL-terminated list */
+	const SANE_Word *word_list;	/* first element is list-length */
+	const SANE_Range *range;
+      }
+    constraint;
+  }
+SANE_Option_Descriptor;
+
+typedef enum
+  {
+    SANE_ACTION_GET_VALUE = 0,
+    SANE_ACTION_SET_VALUE,
+    SANE_ACTION_SET_AUTO
+  }
+SANE_Action;
+
+typedef enum
+  {
+    SANE_FRAME_GRAY,		/* band covering human visual range */
+    SANE_FRAME_RGB,		/* pixel-interleaved red/green/blue bands */
+    SANE_FRAME_RED,		/* red band only */
+    SANE_FRAME_GREEN,		/* green band only */
+    SANE_FRAME_BLUE		/* blue band only */
+  }
+SANE_Frame;
+
+typedef struct
+  {
+    SANE_Frame format;
+    SANE_Bool last_frame;
+    SANE_Int bytes_per_line;
+    SANE_Int pixels_per_line;
+    SANE_Int lines;
+    SANE_Int depth;
+  }
+SANE_Parameters;
+
+struct SANE_Auth_Data;
+
+#define SANE_MAX_USERNAME_LEN	128
+#define SANE_MAX_PASSWORD_LEN	128
+
+typedef void (*SANE_Auth_Callback) (SANE_String_Const resource,
+				    SANE_Char username[SANE_MAX_USERNAME_LEN],
+				    SANE_Char password[SANE_MAX_PASSWORD_LEN]);
+
+extern SANE_Status sane_init (SANE_Int * version_code,
+			      SANE_Auth_Callback authorize);
+extern void sane_exit (void);
+extern SANE_Status sane_get_devices (const SANE_Device *** device_list,
+				     SANE_Bool local_only);
+extern SANE_Status sane_open (SANE_String_Const devicename,
+			      SANE_Handle * handle);
+extern void sane_close (SANE_Handle handle);
+extern const SANE_Option_Descriptor *
+  sane_get_option_descriptor (SANE_Handle handle, SANE_Int option);
+extern SANE_Status sane_control_option (SANE_Handle handle, SANE_Int option,
+					SANE_Action action, void *value,
+					SANE_Int * info);
+extern SANE_Status sane_get_parameters (SANE_Handle handle,
+					SANE_Parameters * params);
+extern SANE_Status sane_start (SANE_Handle handle);
+extern SANE_Status sane_read (SANE_Handle handle, SANE_Byte * data,
+			      SANE_Int max_length, SANE_Int * length);
+extern void sane_cancel (SANE_Handle handle);
+extern SANE_Status sane_set_io_mode (SANE_Handle handle,
+				     SANE_Bool non_blocking);
+extern SANE_Status sane_get_select_fd (SANE_Handle handle,
+				       SANE_Int * fd);
+extern SANE_String_Const sane_strstatus (SANE_Status status);
+
+#endif /* sane_h */
Index: scangearmp2/scangearmp2/src/sane/sanei.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ scangearmp2/scangearmp2/src/sane/sanei.h	2017-08-09 11:34:45.793551706 +0200
@@ -0,0 +1,170 @@
+/* sane - Scanner Access Now Easy.
+   Copyright (C) 1996 David Mosberger-Tang and Andreas Beck
+   Copyright (C) 2002, 2003 Henning Meier-Geinitz
+
+   This file is part of the SANE package.
+
+   SANE is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   SANE is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with sane; see the file COPYING.  If not, write to the Free
+   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   As a special exception, the authors of SANE give permission for
+   additional uses of the libraries contained in this release of SANE.
+
+   The exception is that, if you link a SANE library with other files
+   to produce an executable, this does not by itself cause the
+   resulting executable to be covered by the GNU General Public
+   License.  Your use of that executable is in no way restricted on
+   account of linking the SANE library code into it.
+
+   This exception does not, however, invalidate any other reasons why
+   the executable file might be covered by the GNU General Public
+   License.
+
+   If you submit changes to SANE to the maintainers to be included in
+   a subsequent release, you agree by submitting the changes that
+   those changes may be distributed with this exception intact.
+
+   If you write modifications of your own for SANE, it is your choice
+   whether to permit this exception to apply to your modifications.
+   If you do not wish that, delete this exception notice.
+*/
+
+/** @file sanei.h
+ * Convenience macros and function declarations for backends
+ * @sa sanei_backend.h sanei_thread.h
+ */
+
+/* Doxygen documentation */
+
+/** @mainpage SANEI (SANE internal routines) documentation
+ *
+ * @image html ../images/sane-logo2.jpg
+ * @section intro Introduction
+ *
+ * The header files in the include/sane/ directory named sanei_*.h provide
+ * function declarations and macros that can be used by every SANE backend.
+ * Their implementations can be found in the sanei/ directory. The code aims
+ * to be platform-independent to avoid lots of \#ifdef code in the backends.
+ * Please use the SANEI functions wherever possible.
+ *
+ * This documentation was created by the use of doxygen, the
+ * doc/doxygen-sanei.conf configuration file and dcoumentation in the sanei_*.h
+ * files.
+ *
+ * This documenation is far from complete. Any help is appreciated.
+ *
+ * @section additional Additional documentation
+ * - The SANE standard can be found at <a
+ *   href="http://www.sane-project.org/html/">the SANE webserver</a>.
+ * - Information on how to write a backend: <a
+ *   href="../backend-writing.txt">backend-writing.txt</a>.
+ * - General SANE documentation is on <a
+ *   href="http://www.sane-project.org/docs.html>the SANE documentation
+ *   page</a>.
+ *
+ * @section contact Contact
+ *
+ * The common way to contact the developers of SANE is the sane-devel
+ * mailing list. See the <a
+ * href="http://www.sane-project.org/mailing-lists.html">mailing list webpage</a>
+ * for details. That's the place to ask questions, report bugs, or announce
+ * a new backend.
+ *
+ */
+
+#ifndef sanei_h
+#define sanei_h
+
+#include "sane.h"
+
+/** @name Public macros and functions
+ * @{
+ */
+/** @def STRINGIFY(x)
+ * Turn parameter into string.
+ */
+/** @def PASTE(x,y)
+ * Concatenate parameters.
+ *
+ */
+/** @def NELEMS(a)
+ * Return number of elements of an array.
+ *
+ */
+
+/** @fn extern SANE_Status sanei_check_value (const SANE_Option_Descriptor * opt, void * value);
+ * Check the constraints of a SANE option.
+ *
+ * @param opt   option to check
+ * @param value value of the option
+ *
+ * @return
+ * - SANE_STATUS_GOOD     - on success
+ * - SANE_STATUS_INVAL    - if the value doesn't fit inside the constraint
+ *   or any other error occured
+ * @sa sanei_constrain_value()
+ */
+
+/** @fn extern SANE_Status sanei_constrain_value (const SANE_Option_Descriptor * opt, void * value, SANE_Word * info);
+ * Check the constraints of a SANE option and adjust its value if necessary.
+ *
+ * Depending on the type of the option and constraint, value is modified
+ * to fit inside constraint.
+ *
+ * @param opt   option to check
+ * @param value value of the option
+ * @param info  info is set to SANE_INFO_INEXACT if value was changed
+ *
+ * @return
+ * - SANE_STATUS_GOOD     - on success
+ * - SANE_STATUS_INVAL    - if the function wasn't able to fit value into the
+ *   constraint or any other error occured
+ * @sa sanei_check_value()
+ */
+
+/* @} */
+
+/** @name Private macros
+ * @{
+ */
+/** @def STRINGIFY1(x)
+ * Internal use only.
+ */
+/** @def PASTE1(x,y)
+ * Internal use only.
+ */
+/* @} */
+
+/* A few convenience macros:  */
+/** @hideinitializer */
+#define NELEMS(a)	((int)(sizeof (a) / sizeof (a[0])))
+
+/** @hideinitializer */
+#define STRINGIFY1(x)	#x
+/** @hideinitializer */
+#define STRINGIFY(x)	STRINGIFY1(x)
+
+/** @hideinitializer */
+#define PASTE1(x,y)	x##y
+/** @hideinitializer */
+#define PASTE(x,y)	PASTE1(x,y)
+
+extern SANE_Status sanei_check_value (const SANE_Option_Descriptor * opt,
+				      void * value);
+
+extern SANE_Status sanei_constrain_value (const SANE_Option_Descriptor * opt,
+					  void * value, SANE_Word * info);
+
+
+#endif /* sanei_h */
Index: scangearmp2/scangearmp2/src/sane/sanei_backend.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ scangearmp2/scangearmp2/src/sane/sanei_backend.h	2017-08-09 11:28:34.000000000 +0200
@@ -0,0 +1,175 @@
+/** @file sanei_backend.h
+ * Compatibility header file for backends
+ *
+ * This file provides some defines for macros missing on some platforms.
+ * It also has the SANE API entry points. sanei_backend.h must be included
+ * by every backend.
+ *
+ * @sa sanei.h sanei_thread.h
+ */
+
+
+/** @name Compatibility macros
+ * @{
+ */
+#include "sanei_debug.h"
+
+#if __STDC_VERSION__ >= 199901L
+/* __func__ is provided */
+#elif __GNUC__ >= 5
+/* __func__ is provided */
+#elif __GNUC__ >= 2
+# define __func__ __FUNCTION__
+#else
+# define __func__ "(unknown)"
+#endif
+
+#ifdef HAVE_SYS_HW_H
+  /* OS/2 i/o-port access compatibility macros: */
+# define inb(p)         _inp8 (p)
+# define outb(v,p)      _outp8 ((p),(v))
+# define ioperm(b,l,o)  _portaccess ((b),(b)+(l)-1)
+# define HAVE_IOPERM    1
+#endif
+
+#ifndef HAVE_OS2_H
+#include <fcntl.h>
+#ifndef O_NONBLOCK
+# ifdef O_NDELAY
+#  define O_NONBLOCK O_NDELAY
+# else
+#  ifdef FNDELAY
+#   define O_NONBLOCK FNDELAY    /* last resort */
+#  endif
+# endif
+#endif
+#endif /* HAVE_OS2_H */
+
+#include <limits.h>
+#ifndef PATH_MAX
+# define PATH_MAX 1024
+#endif
+
+#ifndef M_PI
+#define M_PI 3.14159265358979323846
+#endif
+
+#ifndef MM_PER_INCH
+#define MM_PER_INCH 25.4
+#endif
+
+#ifdef HAVE_SIGPROCMASK
+# define SIGACTION      sigaction
+#else
+
+/* Just enough backwards compatibility that we get by in the backends
+   without making handstands.  */
+# ifdef sigset_t
+#  undef sigset_t
+# endif
+# ifdef sigemptyset
+#  undef sigemptyset
+# endif
+# ifdef sigfillset
+#  undef sigfillset
+# endif
+# ifdef sigaddset
+#  undef sigaddset
+# endif
+# ifdef sigdelset
+#  undef sigdelset
+# endif
+# ifdef sigprocmask
+#  undef sigprocmask
+# endif
+# ifdef SIG_BLOCK
+#  undef SIG_BLOCK
+# endif
+# ifdef SIG_UNBLOCK
+#  undef SIG_UNBLOCK
+# endif
+# ifdef SIG_SETMASK
+#  undef SIG_SETMASK
+# endif
+
+# define sigset_t               int
+# define sigemptyset(set)       do { *(set) = 0; } while (0)
+# define sigfillset(set)        do { *(set) = ~0; } while (0)
+# define sigaddset(set,signal)  do { *(set) |= sigmask (signal); } while (0)
+# define sigdelset(set,signal)  do { *(set) &= ~sigmask (signal); } while (0)
+# define sigaction(sig,new,old) sigvec (sig,new,old)
+
+  /* Note: it's not safe to just declare our own "struct sigaction" since
+     some systems (e.g., some versions of OpenStep) declare that structure,
+     but do not implement sigprocmask().  Hard to believe, aint it?  */
+# define SIGACTION              sigvec
+# define SIG_BLOCK      1
+# define SIG_UNBLOCK    2
+# define SIG_SETMASK    3
+#endif /* !HAVE_SIGPROCMASK */
+/* @} */
+
+
+/** @name Declaration of entry points:
+ * @{
+ */
+extern SANE_Status ENTRY(init) (SANE_Int *, SANE_Auth_Callback);
+extern SANE_Status ENTRY(get_devices) (const SANE_Device ***, SANE_Bool);
+extern SANE_Status ENTRY(open) (SANE_String_Const, SANE_Handle *);
+extern const SANE_Option_Descriptor *
+  ENTRY(get_option_descriptor) (SANE_Handle, SANE_Int);
+extern SANE_Status ENTRY(control_option) (SANE_Handle, SANE_Int, SANE_Action,
+                                          void *, SANE_Word *);
+extern SANE_Status ENTRY(get_parameters) (SANE_Handle, SANE_Parameters *);
+extern SANE_Status ENTRY(start) (SANE_Handle);
+extern SANE_Status ENTRY(read) (SANE_Handle, SANE_Byte *, SANE_Int,
+                                SANE_Int *);
+extern SANE_Status ENTRY(set_io_mode) (SANE_Handle, SANE_Bool);
+extern SANE_Status ENTRY(get_select_fd) (SANE_Handle, SANE_Int *);
+extern void ENTRY(cancel) (SANE_Handle);
+extern void ENTRY(close) (SANE_Handle);
+extern void ENTRY(exit) (void);
+
+#ifndef STUBS
+/* Now redirect sane_* calls to backend's functions: */
+
+#define sane_init(a,b)                  ENTRY(init) (a,b)
+#define sane_get_devices(a,b)           ENTRY(get_devices) (a,b)
+#define sane_open(a,b)                  ENTRY(open) (a,b)
+#define sane_get_option_descriptor(a,b) ENTRY(get_option_descriptor) (a,b)
+#define sane_control_option(a,b,c,d,e)  ENTRY(control_option) (a,b,c,d,e)
+#define sane_get_parameters(a,b)        ENTRY(get_parameters) (a,b)
+#define sane_start(a)                   ENTRY(start) (a)
+#define sane_read(a,b,c,d)              ENTRY(read) (a,b,c,d)
+#define sane_set_io_mode(a,b)           ENTRY(set_io_mode) (a,b)
+#define sane_get_select_fd(a,b)         ENTRY(get_select_fd) (a,b)
+#define sane_cancel(a)                  ENTRY(cancel) (a)
+#define sane_close(a)                   ENTRY(close) (a)
+#define sane_exit(a)                    ENTRY(exit) (a)
+#endif /* STUBS */
+/* @} */
+
+/** Internationalization for SANE backends
+ *
+ * Add SANE_I18N() to all texts that can be translated.
+ * E.g. out_txt = SANE_I18N("Hello");
+ */
+#ifndef SANE_I18N
+#define SANE_I18N(text) text
+#endif
+
+/** Option_Value union
+ *
+ * Convenience union to access option values given to the backend
+ */
+#ifndef SANE_OPTION
+typedef union
+{
+  SANE_Bool b;		/**< bool */
+  SANE_Word w;		/**< word */
+  SANE_Word *wa;	/**< word array */
+  SANE_String s;	/**< string */
+}
+Option_Value;
+#define SANE_OPTION 1
+#endif
Index: scangearmp2/scangearmp2/src/sane/sanei_debug.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ scangearmp2/scangearmp2/src/sane/sanei_debug.h	2017-08-09 11:34:45.801551706 +0200
@@ -0,0 +1,176 @@
+/** @file sanei_debug.h
+ * Support for printing debug messages.
+ *
+ * Use the functions of this header file to print debug or warning messages.
+ */
+
+#ifndef _SANEI_DEBUG_H
+#define _SANEI_DEBUG_H
+
+#include "sanei.h"
+
+/** @name Public macros
+ * These macros can be used in backends and other SANE-related
+ * code.
+ *
+ * Before including sanei_debug.h, the following macros must be set:
+ *
+ * - BACKEND_NAME - The name of your backend without double-quotes (must be set in any case)
+ * - STUBS - If this is defined, no macros will be included. Used in
+ *   backends consisting of more than one .c file.
+ * - DEBUG_DECLARE_ONLY - Generates prototypes instead of functions. Used in
+ *   backends consisting of more than one .c file.
+ * - DEBUG_NOT_STATIC - Doesn't generate static functions. Used in header files if
+ *   they are include in more than one .c file.
+ *
+ * @{
+ */
+
+/** @def DBG_INIT()
+ * Initialize sanei_debug.
+ *
+ * Call this function before you use any DBG function.
+ */
+
+/** @def DBG(level, fmt, ...)
+ * Print a message at debug level `level' or higher using a printf-like
+ * function. Example: DBG(1, "sane_open: opening fd \%d\\n", fd).
+ *
+ * @param level debug level
+ * @param fmt format (see man 3 printf for details)
+ * @param ... additional arguments
+ */
+
+/** @def IF_DBG(x)
+ * Compile code only if debugging is enabled.
+ *
+ * Expands to x if debug support is enabled at compile-time. If NDEBUG is
+ * defined at compile-time this macro expands to nothing.
+ *
+ * @param x code to expand when debugging is enabled
+ */
+
+/**
+ * @def DBG_LEVEL
+ * Current debug level.
+ *
+ * You can only read this "variable".
+ */
+
+/** @def ENTRY(name)
+ * Expands to sane_BACKEND_NAME_name.
+ *
+ * Example: ENTRY(init) in mustek.c will expand to sane_mustek_init.
+ */
+
+/* @} */
+
+/** @name Internal macros and functions
+ * Do not use in your own code.
+ * @{
+ */
+
+/** @def DBG_LOCAL
+ * Do not use in backends directly.
+ *
+ * Internal wrapper for printing function.
+ */
+
+/** @fn extern void sanei_init_debug (const char * backend, int * debug_level_var);
+ * Do not use in backends directly.
+ *
+ * Actual init function.
+ */
+
+/** @fn extern void sanei_debug_msg (int level, int max_level, const char *be, const char *fmt, va_list ap);
+ * Do not use in backends directly.
+ *
+ * Actual printing function.
+ */
+/* @} */
+
+                                  /** @hideinitializer*/
+#define ENTRY(name)     PASTE(PASTE(PASTE(sane_,BACKEND_NAME),_),name)
+
+#ifdef NDEBUG
+
+extern void sanei_debug_ndebug (int level, const char *msg, ...);
+
+# define DBG_LEVEL	(0)
+# define DBG_INIT()
+# define DBG		sanei_debug_ndebug
+# define IF_DBG(x)
+
+#else /* !NDEBUG */
+
+                                  /** @hideinitializer*/
+# define DBG_LEVEL      PASTE(sanei_debug_,BACKEND_NAME)
+
+# if defined(BACKEND_NAME) && !defined(STUBS)
+#  ifdef DEBUG_DECLARE_ONLY
+extern int DBG_LEVEL;
+#  else /* !DEBUG_DECLARE_ONLY */
+int DBG_LEVEL = 0;
+#  endif /* DEBUG_DECLARE_ONLY */
+# endif /* BACKEND_NAME && !STUBS */
+
+                                  /** @hideinitializer*/
+# define DBG_INIT()                                     \
+  sanei_init_debug (STRINGIFY(BACKEND_NAME), &DBG_LEVEL)
+
+                                  /** @hideinitializer*/
+# define DBG_LOCAL	PASTE(DBG_LEVEL,_call)
+
+
+# ifndef STUBS
+
+#  ifdef DEBUG_DECLARE_ONLY
+
+extern void DBG_LOCAL (int level, const char *msg, ...)
+#ifdef __GNUC__
+__attribute__ ((format (printf, 2, 3)))
+#endif
+;
+
+#  else /* !DEBUG_DECLARE_ONLY */
+
+#   include <stdarg.h>
+
+extern void sanei_debug_msg
+  (int level, int max_level, const char *be, const char *fmt, va_list ap);
+
+#ifdef __GNUC__
+#   ifndef DEBUG_NOT_STATIC
+static
+#   endif /* !DEBUG_NOT_STATIC */
+void DBG_LOCAL (int level, const char *msg, ...) __attribute__ ((format (printf, 2, 3)));
+#endif /* __GNUC__ */
+
+#   ifndef DEBUG_NOT_STATIC
+static
+#   endif /* !DEBUG_NOT_STATIC */
+void
+DBG_LOCAL (int level, const char *msg, ...)
+{
+  va_list ap;
+
+  va_start (ap, msg);
+  sanei_debug_msg (level, DBG_LEVEL, STRINGIFY(BACKEND_NAME), msg, ap);
+  va_end (ap);
+}
+
+#  endif /* DEBUG_DECLARE_ONLY */
+
+# endif /* !STUBS */
+
+                                  /** @hideinitializer*/
+# define DBG            DBG_LOCAL
+
+extern void sanei_init_debug (const char * backend, int * debug_level_var);
+
+                                  /** @hideinitializer*/
+# define IF_DBG(x)      x
+
+#endif /* NDEBUG */
+
+#endif /* _SANEI_DEBUG_H */
Index: scangearmp2/scangearmp2/src/sane/sanei_init_debug.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ scangearmp2/scangearmp2/src/sane/sanei_init_debug.c	2017-08-09 11:34:45.801551706 +0200
@@ -0,0 +1,109 @@
+/* sane - Scanner Access Now Easy.
+   Copyright (C) 1996, 1997 David Mosberger-Tang and Andreas Beck
+   This file is part of the SANE package.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA.
+
+   As a special exception, the authors of SANE give permission for
+   additional uses of the libraries contained in this release of SANE.
+
+   The exception is that, if you link a SANE library with other files
+   to produce an executable, this does not by itself cause the
+   resulting executable to be covered by the GNU General Public
+   License.  Your use of that executable is in no way restricted on
+   account of linking the SANE library code into it.
+
+   This exception does not, however, invalidate any other reasons why
+   the executable file might be covered by the GNU General Public
+   License.
+
+   If you submit changes to SANE to the maintainers to be included in
+   a subsequent release, you agree by submitting the changes that
+   those changes may be distributed with this exception intact.
+
+   If you write modifications of your own for SANE, it is your choice
+   whether to permit this exception to apply to your modifications.
+   If you do not wish that, delete this exception notice.  */
+
+//#include "../include/sane/config.h"
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <string.h>
+#include <stdarg.h>
+#include <syslog.h>
+#ifdef HAVE_OS2_H
+#include <sys/types.h>
+#endif
+#include <sys/stat.h>
+
+#ifdef HAVE_OS2_H
+# define INCL_DOS
+# include <os2.h>
+#endif
+
+#define BACKEND_NAME sanei_debug
+#include "sanei_debug.h"
+
+void
+sanei_init_debug (const char * backend, int * var)
+{
+  char ch, buf[256] = "SANE_DEBUG_";
+  const char * val;
+  unsigned int i;
+
+  *var = 0;
+
+  for (i = 11; (ch = backend[i - 11]) != 0; ++i)
+    {
+      if (i >= sizeof (buf) - 1)
+        break;
+      buf[i] = toupper(ch);
+    }
+  buf[i] = '\0';
+
+  val = getenv (buf);
+
+  if (!val)
+    return;
+
+  *var = atoi (val);
+
+  DBG (0, "Setting debug level of %s to %d.\n", backend, *var);
+}
+
+void
+sanei_debug_msg
+  (int level, int max_level, const char *be, const char *fmt, va_list ap)
+{
+  if (max_level >= level)
+    {
+        fprintf (stderr, "[%s] ", be);
+        vfprintf (stderr, fmt, ap);
+    }
+}
+
+#ifdef NDEBUG
+void
+sanei_debug_ndebug (int level, const char *fmt, ...)
+{
+  /* this function is never called */
+}
+#endif
Index: scangearmp2/scangearmp2/src/sane/saneopts.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ scangearmp2/scangearmp2/src/sane/saneopts.h	2017-08-09 11:28:34.000000000 +0200
@@ -0,0 +1,397 @@
+/* sane - Scanner Access Now Easy.
+   Copyright (C) 1996, 1997 David Mosberger-Tang and Andreas Beck
+   This file is part of the SANE package.
+
+   SANE is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   SANE is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with sane; see the file COPYING.  If not, write to the Free
+   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   As a special exception, the authors of SANE give permission for
+   additional uses of the libraries contained in this release of SANE.
+
+   The exception is that, if you link a SANE library with other files
+   to produce an executable, this does not by itself cause the
+   resulting executable to be covered by the GNU General Public
+   License.  Your use of that executable is in no way restricted on
+   account of linking the SANE library code into it.
+
+   This exception does not, however, invalidate any other reasons why
+   the executable file might be covered by the GNU General Public
+   License.
+
+   If you submit changes to SANE to the maintainers to be included in
+   a subsequent release, you agree by submitting the changes that
+   those changes may be distributed with this exception intact.
+
+   If you write modifications of your own for SANE, it is your choice
+   whether to permit this exception to apply to your modifications.
+   If you do not wish that, delete this exception notice.
+
+   This file declares common option names, titles, and descriptions.  A
+   backend is not limited to these options but for the sake of
+   consistency it's better to use options declared here when appropriate.
+*/
+
+/* This file defines several option NAMEs, TITLEs and DESCs
+   that are (or should be) used by several backends.
+
+   All well known options should be listed here. But this does
+   not mean that all options that are listed here are well known options.
+   To find out if an option is a well known option and how well known
+   options have to be defined please take a look at the sane standard!!!
+ */
+#ifndef saneopts_h
+#define saneopts_h
+
+#ifndef SANE_I18N
+#define SANE_I18N(text) text
+#endif
+
+/* This _must_ be the first option (index 0): */
+#define SANE_NAME_NUM_OPTIONS		""	/* never settable */
+#define SANE_NAME_PREVIEW		"preview"
+#define SANE_NAME_GRAY_PREVIEW		"preview-in-gray"
+#define SANE_NAME_BIT_DEPTH		"depth"
+#define SANE_NAME_SCAN_MODE		"mode"
+#define SANE_NAME_SCAN_SPEED		"speed"
+#define SANE_NAME_SCAN_SOURCE		"source"
+#define SANE_NAME_BACKTRACK		"backtrack"
+/* Most user-interfaces will let the user specify the scan area as the
+   top-left corner and the width/height of the scan area.  The reason
+   the backend interface uses the top-left/bottom-right corner is so
+   that the scan area values can be properly constraint independent of
+   any other option value.  */
+#define SANE_NAME_SCAN_TL_X		"tl-x"
+#define SANE_NAME_SCAN_TL_Y		"tl-y"
+#define SANE_NAME_SCAN_BR_X		"br-x"
+#define SANE_NAME_SCAN_BR_Y		"br-y"
+#define SANE_NAME_SCAN_RESOLUTION	"resolution"
+#define SANE_NAME_SCAN_X_RESOLUTION	"resolution"
+#define SANE_NAME_SCAN_Y_RESOLUTION	"y-resolution"
+#define SANE_NAME_CUSTOM_GAMMA		"custom-gamma"
+#define SANE_NAME_GAMMA_VECTOR		"gamma-table"
+#define SANE_NAME_GAMMA_VECTOR_R	"red-gamma-table"
+#define SANE_NAME_GAMMA_VECTOR_G	"green-gamma-table"
+#define SANE_NAME_GAMMA_VECTOR_B	"blue-gamma-table"
+#define SANE_NAME_BRIGHTNESS		"brightness"
+#define SANE_NAME_CONTRAST		"contrast"
+#define SANE_NAME_GRAIN_SIZE		"grain"
+#define SANE_NAME_HALFTONE		"halftoning"
+#define SANE_NAME_BLACK_LEVEL           "black-level"
+#define SANE_NAME_WHITE_LEVEL           "white-level"
+#define SANE_NAME_WHITE_LEVEL_R         "white-level-r"
+#define SANE_NAME_WHITE_LEVEL_G         "white-level-g"
+#define SANE_NAME_WHITE_LEVEL_B         "white-level-b"
+#define SANE_NAME_SHADOW		"shadow"
+#define SANE_NAME_SHADOW_R		"shadow-r"
+#define SANE_NAME_SHADOW_G		"shadow-g"
+#define SANE_NAME_SHADOW_B		"shadow-b"
+#define SANE_NAME_HIGHLIGHT		"highlight"
+#define SANE_NAME_HIGHLIGHT_R		"highlight-r"
+#define SANE_NAME_HIGHLIGHT_G		"highlight-g"
+#define SANE_NAME_HIGHLIGHT_B		"highlight-b"
+#define SANE_NAME_HUE			"hue"
+#define SANE_NAME_SATURATION		"saturation"
+#define SANE_NAME_FILE			"filename"
+#define SANE_NAME_HALFTONE_DIMENSION	"halftone-size"
+#define SANE_NAME_HALFTONE_PATTERN	"halftone-pattern"
+#define SANE_NAME_RESOLUTION_BIND	"resolution-bind"
+#define SANE_NAME_NEGATIVE		"negative"
+#define SANE_NAME_QUALITY_CAL		"quality-cal"
+#define SANE_NAME_DOR			"double-res"
+#define SANE_NAME_RGB_BIND		"rgb-bind"
+#define SANE_NAME_THRESHOLD		"threshold"
+#define SANE_NAME_ANALOG_GAMMA		"analog-gamma"
+#define SANE_NAME_ANALOG_GAMMA_R	"analog-gamma-r"
+#define SANE_NAME_ANALOG_GAMMA_G	"analog-gamma-g"
+#define SANE_NAME_ANALOG_GAMMA_B	"analog-gamma-b"
+#define SANE_NAME_ANALOG_GAMMA_BIND	"analog-gamma-bind"
+#define SANE_NAME_WARMUP		"warmup"
+#define SANE_NAME_CAL_EXPOS_TIME	"cal-exposure-time"
+#define SANE_NAME_CAL_EXPOS_TIME_R	"cal-exposure-time-r"
+#define SANE_NAME_CAL_EXPOS_TIME_G	"cal-exposure-time-g"
+#define SANE_NAME_CAL_EXPOS_TIME_B	"cal-exposure-time-b"
+#define SANE_NAME_SCAN_EXPOS_TIME	"scan-exposure-time"
+#define SANE_NAME_SCAN_EXPOS_TIME_R	"scan-exposure-time-r"
+#define SANE_NAME_SCAN_EXPOS_TIME_G	"scan-exposure-time-g"
+#define SANE_NAME_SCAN_EXPOS_TIME_B	"scan-exposure-time-b"
+#define SANE_NAME_SELECT_EXPOSURE_TIME	"select-exposure-time"
+#define SANE_NAME_CAL_LAMP_DEN		"cal-lamp-density"
+#define SANE_NAME_SCAN_LAMP_DEN		"scan-lamp-density"
+#define SANE_NAME_SELECT_LAMP_DENSITY	"select-lamp-density"
+#define SANE_NAME_LAMP_OFF_AT_EXIT	"lamp-off-at-exit"
+
+#define SANE_TITLE_NUM_OPTIONS		SANE_I18N("Number of options")
+#define SANE_TITLE_PREVIEW		SANE_I18N("Preview")
+#define SANE_TITLE_GRAY_PREVIEW		SANE_I18N("Force monochrome preview")
+#define SANE_TITLE_BIT_DEPTH		SANE_I18N("Bit depth")
+#define SANE_TITLE_SCAN_MODE		SANE_I18N("Scan mode")
+#define SANE_TITLE_SCAN_SPEED		SANE_I18N("Scan speed")
+#define SANE_TITLE_SCAN_SOURCE		SANE_I18N("Scan source")
+#define SANE_TITLE_BACKTRACK		SANE_I18N("Force backtracking")
+#define SANE_TITLE_SCAN_TL_X		SANE_I18N("Top-left x")
+#define SANE_TITLE_SCAN_TL_Y		SANE_I18N("Top-left y")
+#define SANE_TITLE_SCAN_BR_X		SANE_I18N("Bottom-right x")
+#define SANE_TITLE_SCAN_BR_Y		SANE_I18N("Bottom-right y")
+#define SANE_TITLE_SCAN_RESOLUTION	SANE_I18N("Scan resolution")
+#define SANE_TITLE_SCAN_X_RESOLUTION	SANE_I18N("X-resolution")
+#define SANE_TITLE_SCAN_Y_RESOLUTION	SANE_I18N("Y-resolution")
+#define SANE_TITLE_CUSTOM_GAMMA		SANE_I18N("Use custom gamma table")
+#define SANE_TITLE_GAMMA_VECTOR		SANE_I18N("Image intensity")
+#define SANE_TITLE_GAMMA_VECTOR_R	SANE_I18N("Red intensity")
+#define SANE_TITLE_GAMMA_VECTOR_G	SANE_I18N("Green intensity")
+#define SANE_TITLE_GAMMA_VECTOR_B	SANE_I18N("Blue intensity")
+#define SANE_TITLE_BRIGHTNESS		SANE_I18N("Brightness")
+#define SANE_TITLE_CONTRAST		SANE_I18N("Contrast")
+#define SANE_TITLE_GRAIN_SIZE		SANE_I18N("Grain size")
+#define SANE_TITLE_HALFTONE		SANE_I18N("Halftoning")
+#define SANE_TITLE_BLACK_LEVEL          SANE_I18N("Black level")
+#define SANE_TITLE_WHITE_LEVEL          SANE_I18N("White level")
+#define SANE_TITLE_WHITE_LEVEL_R        SANE_I18N("White level for red")
+#define SANE_TITLE_WHITE_LEVEL_G        SANE_I18N("White level for green")
+#define SANE_TITLE_WHITE_LEVEL_B        SANE_I18N("White level for blue")
+#define SANE_TITLE_SHADOW		SANE_I18N("Shadow")
+#define SANE_TITLE_SHADOW_R		SANE_I18N("Shadow for red")
+#define SANE_TITLE_SHADOW_G		SANE_I18N("Shadow for green")
+#define SANE_TITLE_SHADOW_B		SANE_I18N("Shadow for blue")
+#define SANE_TITLE_HIGHLIGHT		SANE_I18N("Highlight")
+#define SANE_TITLE_HIGHLIGHT_R		SANE_I18N("Highlight for red")
+#define SANE_TITLE_HIGHLIGHT_G		SANE_I18N("Highlight for green")
+#define SANE_TITLE_HIGHLIGHT_B		SANE_I18N("Highlight for blue")
+#define SANE_TITLE_HUE			SANE_I18N("Hue")
+#define SANE_TITLE_SATURATION		SANE_I18N("Saturation")
+#define SANE_TITLE_FILE			SANE_I18N("Filename")
+#define SANE_TITLE_HALFTONE_DIMENSION	SANE_I18N("Halftone pattern size")
+#define SANE_TITLE_HALFTONE_PATTERN	SANE_I18N("Halftone pattern")
+#define SANE_TITLE_RESOLUTION_BIND	SANE_I18N("Bind X and Y resolution")
+#define SANE_TITLE_NEGATIVE		SANE_I18N("Negative")
+#define SANE_TITLE_QUALITY_CAL		SANE_I18N("Quality calibration")
+#define SANE_TITLE_DOR			SANE_I18N("Double Optical Resolution")
+#define SANE_TITLE_RGB_BIND		SANE_I18N("Bind RGB")
+#define SANE_TITLE_THRESHOLD		SANE_I18N("Threshold")
+#define SANE_TITLE_ANALOG_GAMMA		SANE_I18N("Analog gamma correction")
+#define SANE_TITLE_ANALOG_GAMMA_R	SANE_I18N("Analog gamma red")
+#define SANE_TITLE_ANALOG_GAMMA_G	SANE_I18N("Analog gamma green")
+#define SANE_TITLE_ANALOG_GAMMA_B	SANE_I18N("Analog gamma blue")
+#define SANE_TITLE_ANALOG_GAMMA_BIND    SANE_I18N("Bind analog gamma")
+#define SANE_TITLE_WARMUP		SANE_I18N("Warmup lamp")
+#define SANE_TITLE_CAL_EXPOS_TIME	SANE_I18N("Cal. exposure-time")
+#define SANE_TITLE_CAL_EXPOS_TIME_R	SANE_I18N("Cal. exposure-time for red")
+#define SANE_TITLE_CAL_EXPOS_TIME_G	SANE_I18N("Cal. exposure-time for " \
+"green")
+#define SANE_TITLE_CAL_EXPOS_TIME_B	SANE_I18N("Cal. exposure-time for blue")
+#define SANE_TITLE_SCAN_EXPOS_TIME	SANE_I18N("Scan exposure-time")
+#define SANE_TITLE_SCAN_EXPOS_TIME_R	SANE_I18N("Scan exposure-time for red")
+#define SANE_TITLE_SCAN_EXPOS_TIME_G	SANE_I18N("Scan exposure-time for " \
+"green")
+#define SANE_TITLE_SCAN_EXPOS_TIME_B	SANE_I18N("Scan exposure-time for blue")
+#define SANE_TITLE_SELECT_EXPOSURE_TIME	SANE_I18N("Set exposure-time")
+#define SANE_TITLE_CAL_LAMP_DEN		SANE_I18N("Cal. lamp density")
+#define SANE_TITLE_SCAN_LAMP_DEN	SANE_I18N("Scan lamp density")
+#define SANE_TITLE_SELECT_LAMP_DENSITY	SANE_I18N("Set lamp density")
+#define SANE_TITLE_LAMP_OFF_AT_EXIT	SANE_I18N("Lamp off at exit")
+
+/* Descriptive/help strings for above options: */
+#define SANE_DESC_NUM_OPTIONS \
+SANE_I18N("Read-only option that specifies how many options a specific " \
+"devices supports.")
+
+#define SANE_DESC_PREVIEW \
+SANE_I18N("Request a preview-quality scan.")
+
+#define SANE_DESC_GRAY_PREVIEW \
+SANE_I18N("Request that all previews are done in monochrome mode.  On a " \
+"three-pass scanner this cuts down the number of passes to one and on a " \
+"one-pass scanner, it reduces the memory requirements and scan-time of the " \
+"preview.")
+
+#define SANE_DESC_BIT_DEPTH \
+SANE_I18N("Number of bits per sample, typical values are 1 for \"line-art\" " \
+"and 8 for multibit scans.")
+
+#define SANE_DESC_SCAN_MODE \
+SANE_I18N("Selects the scan mode (e.g., lineart, monochrome, or color).")
+
+#define SANE_DESC_SCAN_SPEED \
+SANE_I18N("Determines the speed at which the scan proceeds.")
+
+#define SANE_DESC_SCAN_SOURCE \
+SANE_I18N("Selects the scan source (such as a document-feeder).")
+
+#define SANE_DESC_BACKTRACK \
+SANE_I18N("Controls whether backtracking is forced.")
+
+#define SANE_DESC_SCAN_TL_X \
+SANE_I18N("Top-left x position of scan area.")
+
+#define SANE_DESC_SCAN_TL_Y \
+SANE_I18N("Top-left y position of scan area.")
+
+#define SANE_DESC_SCAN_BR_X \
+SANE_I18N("Bottom-right x position of scan area.")
+
+#define SANE_DESC_SCAN_BR_Y \
+SANE_I18N("Bottom-right y position of scan area.")
+
+#define SANE_DESC_SCAN_RESOLUTION \
+SANE_I18N("Sets the resolution of the scanned image.")
+
+#define SANE_DESC_SCAN_X_RESOLUTION \
+SANE_I18N("Sets the horizontal resolution of the scanned image.")
+
+#define SANE_DESC_SCAN_Y_RESOLUTION \
+SANE_I18N("Sets the vertical resolution of the scanned image.")
+
+#define SANE_DESC_CUSTOM_GAMMA \
+SANE_I18N("Determines whether a builtin or a custom gamma-table should be " \
+"used.")
+
+#define SANE_DESC_GAMMA_VECTOR \
+SANE_I18N("Gamma-correction table.  In color mode this option equally " \
+"affects the red, green, and blue channels simultaneously (i.e., it is an " \
+"intensity gamma table).")
+
+#define SANE_DESC_GAMMA_VECTOR_R \
+SANE_I18N("Gamma-correction table for the red band.")
+
+#define SANE_DESC_GAMMA_VECTOR_G \
+SANE_I18N("Gamma-correction table for the green band.")
+
+#define SANE_DESC_GAMMA_VECTOR_B \
+SANE_I18N("Gamma-correction table for the blue band.")
+
+#define SANE_DESC_BRIGHTNESS \
+SANE_I18N("Controls the brightness of the acquired image.")
+
+#define SANE_DESC_CONTRAST \
+SANE_I18N("Controls the contrast of the acquired image.")
+
+#define SANE_DESC_GRAIN_SIZE \
+SANE_I18N("Selects the \"graininess\" of the acquired image.  Smaller values " \
+"result in sharper images.")
+
+#define SANE_DESC_HALFTONE \
+SANE_I18N("Selects whether the acquired image should be halftoned (dithered).")
+
+#define SANE_DESC_BLACK_LEVEL \
+SANE_I18N("Selects what radiance level should be considered \"black\".")
+
+#define SANE_DESC_WHITE_LEVEL \
+SANE_I18N("Selects what radiance level should be considered \"white\".")
+
+#define SANE_DESC_WHITE_LEVEL_R \
+SANE_I18N("Selects what red radiance level should be considered \"white\".")
+
+#define SANE_DESC_WHITE_LEVEL_G \
+SANE_I18N("Selects what green radiance level should be considered \"white\".")
+
+#define SANE_DESC_WHITE_LEVEL_B \
+SANE_I18N("Selects what blue radiance level should be considered \"white\".")
+
+#define SANE_DESC_SHADOW \
+SANE_I18N("Selects what radiance level should be considered \"black\".")
+#define SANE_DESC_SHADOW_R \
+SANE_I18N("Selects what red radiance level should be considered \"black\".")
+#define SANE_DESC_SHADOW_G \
+SANE_I18N("Selects what green radiance level should be considered \"black\".")
+#define SANE_DESC_SHADOW_B \
+SANE_I18N("Selects what blue radiance level should be considered \"black\".")
+
+#define SANE_DESC_HIGHLIGHT \
+SANE_I18N("Selects what radiance level should be considered \"white\".")
+#define SANE_DESC_HIGHLIGHT_R \
+SANE_I18N("Selects what red radiance level should be considered \"full red\".")
+#define SANE_DESC_HIGHLIGHT_G \
+SANE_I18N("Selects what green radiance level should be considered \"full " \
+"green\".")
+#define SANE_DESC_HIGHLIGHT_B \
+SANE_I18N("Selects what blue radiance level should be considered \"full " \
+"blue\".")
+
+#define SANE_DESC_HUE \
+SANE_I18N("Controls the \"hue\" (blue-level) of the acquired image.")
+
+#define SANE_DESC_SATURATION \
+SANE_I18N("The saturation level controls the amount of \"blooming\" that " \
+"occurs when acquiring an image with a camera. Larger values cause more " \
+"blooming.")
+
+#define SANE_DESC_FILE \
+SANE_I18N("The filename of the image to be loaded.")
+
+#define SANE_DESC_HALFTONE_DIMENSION \
+SANE_I18N("Sets the size of the halftoning (dithering) pattern used when " \
+"scanning halftoned images.")
+
+#define SANE_DESC_HALFTONE_PATTERN \
+SANE_I18N("Defines the halftoning (dithering) pattern for scanning " \
+"halftoned images.")
+
+#define SANE_DESC_RESOLUTION_BIND \
+SANE_I18N("Use same values for X and Y resolution")
+#define SANE_DESC_NEGATIVE \
+SANE_I18N("Swap black and white")
+#define SANE_DESC_QUALITY_CAL \
+SANE_I18N("Do a quality white-calibration")
+#define SANE_DESC_DOR \
+SANE_I18N("Use lens that doubles optical resolution")
+#define SANE_DESC_RGB_BIND \
+SANE_I18N("In RGB-mode use same values for each color")
+#define SANE_DESC_THRESHOLD \
+SANE_I18N("Select minimum-brightness to get a white point")
+#define SANE_DESC_ANALOG_GAMMA \
+SANE_I18N("Analog gamma-correction")
+#define SANE_DESC_ANALOG_GAMMA_R \
+SANE_I18N("Analog gamma-correction for red")
+#define SANE_DESC_ANALOG_GAMMA_G \
+SANE_I18N("Analog gamma-correction for green")
+#define SANE_DESC_ANALOG_GAMMA_B \
+SANE_I18N("Analog gamma-correction for blue")
+#define SANE_DESC_ANALOG_GAMMA_BIND \
+SANE_I18N("In RGB-mode use same values for each color")
+#define SANE_DESC_WARMUP \
+SANE_I18N("Warmup lamp before scanning")
+#define SANE_DESC_CAL_EXPOS_TIME \
+SANE_I18N("Define exposure-time for calibration")
+#define SANE_DESC_CAL_EXPOS_TIME_R \
+SANE_I18N("Define exposure-time for red calibration")
+#define SANE_DESC_CAL_EXPOS_TIME_G \
+SANE_I18N("Define exposure-time for green calibration")
+#define SANE_DESC_CAL_EXPOS_TIME_B \
+SANE_I18N("Define exposure-time for blue calibration")
+#define SANE_DESC_SCAN_EXPOS_TIME \
+SANE_I18N("Define exposure-time for scan")
+#define SANE_DESC_SCAN_EXPOS_TIME_R \
+SANE_I18N("Define exposure-time for red scan")
+#define SANE_DESC_SCAN_EXPOS_TIME_G \
+SANE_I18N("Define exposure-time for green scan")
+#define SANE_DESC_SCAN_EXPOS_TIME_B \
+SANE_I18N("Define exposure-time for blue scan")
+#define SANE_DESC_SELECT_EXPOSURE_TIME \
+SANE_I18N("Enable selection of exposure-time")
+#define SANE_DESC_CAL_LAMP_DEN \
+SANE_I18N("Define lamp density for calibration")
+#define SANE_DESC_SCAN_LAMP_DEN \
+SANE_I18N("Define lamp density for scan")
+#define SANE_DESC_SELECT_LAMP_DENSITY \
+SANE_I18N("Enable selection of lamp density")
+#define SANE_DESC_LAMP_OFF_AT_EXIT \
+SANE_I18N("Turn off lamp when program exits")
+
+/* Typical values for stringlists (to keep the backends consistent) */
+
+#define SANE_VALUE_SCAN_MODE_COLOR		SANE_I18N("Color")
+#define SANE_VALUE_SCAN_MODE_GRAY		SANE_I18N("Gray")
+#define SANE_VALUE_SCAN_MODE_LINEART		SANE_I18N("Lineart")
+
+#endif /* saneopts_h */
Index: scangearmp2/scangearmp2/src/support.h
===================================================================
--- scangearmp2.orig/scangearmp2/src/support.h	2017-08-09 11:28:10.921567978 +0200
+++ scangearmp2/scangearmp2/src/support.h	2017-08-09 11:34:45.809551706 +0200
@@ -90,7 +90,7 @@
 {
 	GtkBuilder	*builder;
 	gboolean	ignore_combobox_changed;
-	
+
 	/* main window */
 	GtkWidget	*window_main;
 	GtkWidget	*combobox_scanmode;
@@ -100,13 +100,13 @@
 	gboolean	window_main_sensitive;
 	gint		window_main_value;
 	int			prev_scanmode;
-	
+
 	GtkWidget	*button_scanjpeg;
 	GtkWidget	*button_scanpdf;
 	GtkWidget	*button_version;
 	GtkWidget	*button_close;
 	GtkWidget	*label_devname;
-	
+
 	/* select device dialog */
 	GtkWidget	*dialog_select;
 	GtkWidget	*combobox_select_devlist;
@@ -116,7 +116,7 @@
 	GtkWidget	*button_select_ok;
 	gboolean	dialog_select_sensitive;
 	gint		dialog_select_value;
-	
+
 	/* save dialog */
 	GtkWidget	*dialog_save;
 	GtkWidget	*filechooserwidget_save;
@@ -124,7 +124,7 @@
 	GtkWidget	*button_save_save;
 	gboolean	dialog_save_sensitive;
 	gint		dialog_save_value;
-	
+
 	/* version dialog */
 	GtkWidget	*dialog_version;
 	GtkWidget	*label_version_app;
@@ -132,11 +132,11 @@
 	GtkWidget	*label_version_cpy;
 	GtkWidget	*button_version_ok;
 	gint		dialog_version_value;
-	
+
 	/* notify dialog */
 	GtkWidget	*dialog_notify;
 	GtkWidget	*label_notify_save;
-	
+
 	/* progress bar dialog */
 	GtkWidget	*dialog_progress;
 	GtkWidget	*progressbar_prog;
@@ -145,26 +145,26 @@
 	GtkWidget	*label_prog_pages;
 	GtkWidget	*button_prog_cancel;
 	gint		dialog_progress_value;
-	
+
 	/* error dialog */
 	GtkWidget	*dialog_error;
 	GtkWidget	*label_error_msg;
 	GtkWidget	*button_error_cancel;
 	GtkWidget	*button_error_ok;
 	gint		dialog_error_value;
-	
+
 	/* scan parameters */
 	int			scan_scanmode;
 	int			scan_source;
 	int			scan_color;
 	int			scan_size;
-	
+
 	int			scan_format;
-	
+
 	int			scan_result;
 	int			scanning_page;
 	char		file_path[ PATH_MAX ];
-	
+
 	int			scan_w;
 	int			scan_h;
 	int			scan_res;
@@ -172,6 +172,27 @@
 	int			last_error_quit;
 }SGMP_Data;
 
+typedef struct
+{
+	/* scan parameters */
+	int			scan_scanmode;
+	int			scan_source;
+	int			scan_color;
+	int			scan_size;
+
+	int			scan_format;
+
+	int			scan_result;
+	int			scanning_page;
+	char		file_path[ PATH_MAX ];
+
+	int			scan_w;
+	int			scan_h;
+	int			scan_res;
+	/* error */
+	int			last_error_quit;
+}SGMP_Data_Lite;
+
 
 /*
  	Public enum.
